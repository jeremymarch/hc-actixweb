<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hoplite Challenge</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<!--
    <script type="text/javascript" src="jquery.min.js"></script>
    <script type="text/javascript" src="wordtree.js?v10"></script>
    <script src="https://code.jquery.com/jquery-3.6.1.min.js" 
        integrity="sha256-o88AwQnZB+VDvE9tvIXrMQaPlFFSUTR+nldQm1LuPXQ=" 
        crossorigin="anonymous"></script>
-->
<script>
    'use strict';
    function q(i) {return document.querySelector(i)}
    function setTheme() {
        let mode = localStorage.getItem("mode");
        if ((window.matchMedia( "(prefers-color-scheme: dark)" ).matches || mode == "dark") && mode != "light") {
            q("HTML").classList.add("dark");
        }
        else {
            q("HTML").classList.remove("dark");
        }
    }
    setTheme();    
    </script>
    <style>
@font-face {
    font-family: 'WebNewAthenaUnicode';
    src: url('/newathu5_8.ttf') format('truetype');
}
BODY { font-family:helvetica neue,helvetica, arial, sans-serif;margin:0px; }
.gkinput, .gkinputnontyping {
    font-family: WebNewAthenaUnicode,NewAthenaUnicode, helvetica,arial;
}
#mainTime { font-size:14pt;}
.sym {
    font-family: "AppleColorEmoji","Apple Color Emoji","Segoe UI Emoji",'Noto Color Emoji',"NotoColorEmoji","Segoe UI Symbol","EmojiSymbols",Symbola,"Android Emoji","AndroidEmoji","Arial Unicode MS","Zapf Dingbats","AppleSDGothicNeo-Regular","lucida grande",tahoma,verdana,arial,sans-serif;
    text-rendering: optimizeLegibility;
}
.gkinput, .gkinputcodes, .gkinputnontyping {
    -webkit-box-sizing: border-box; /* Safari/Chrome, other WebKit */
    -moz-box-sizing: border-box;    /* Firefox, other Gecko */
    box-sizing: border-box;         /* Opera/IE 8+ */
    width: 100%;
    padding: 0px 0.5em;
    height: 40px;
    font-size: 20pt;
    margin:6px 0px;
    resize: none;
}
/*.gkinput:focus, .gkinputcodes:focus, .gkinputnontyping:focus{
    outline:2px solid #6677dd;
}*/

.startingform {
    width:100%;
    display:flex;
    justify-content: center;
    align-items: center;
    margin:0px auto;
    height:90px;
    font-size:24pt;
    border:1px solid black;
    text-align: center;
    border-radius:6px;
    font-family: WebNewAthenaUnicode,NewAthenaUnicode, helvetica,arial;
}
.newform {
    width:100%;
    display:block;
    margin:0px auto;
    height:90px;
    font-size:24pt;
    border:1px solid black;
    text-align: center;
    padding-top:20px;
    border-radius:6px;
    font-family: WebNewAthenaUnicode,NewAthenaUnicode, helvetica,arial;
}
.changedesc {
    width:100%;
    display:block;
    margin:10px auto;
    height:42px;
    font-size:16pt;
    text-align: center;
    padding-top: 16px;
}
#statusmesg {
    display: block;
    margin: 0px auto;
    font-size: 12pt;
    text-align: center;
    border-top: 1px solid black;
    padding-top: 4px;
}
.correctanswer {
    width:100%;
    display:block;
    margin:10px auto;
    font-size:24pt;
    text-align: center;
    height:42px;
}
#submitbutton {
    margin:10px auto;
    width:100px;
    height:26px;
    display: block;
    margin-bottom: 20px;
}
#mainstopwatch {
    float:right;
}
.hbox {
    width:100%;
    margin:10px auto;
    height:30px;
    margin-top: 0px;
}
#askparamsdiv {
    width:100%;
    margin:0px auto;
}
#askparamsdivinner SELECT { display:block;}
#askparamsdivinner {
    width:100%;
    margin:0px auto;
    justify-content: center;
    display:flex;
}
.mfbutton {
    float: left;
    width: 55px;
    height: 26px;
}

#settings {
    border:2px solid black;
    width:300px;
    position: absolute;
    top: 28px;
    left: 10px;
    padding:10px;
    height:120px;
}
.addheight{
    top:28px;
}
#list {
border:2px solid black;
    width:320px;
    position: absolute;
    top: 170px;
    left: 10px;
    transition: top 2s;
    z-index:899;
    
}
#creategamebutton {
    display: block;
}
#menubar {
    height:20px;
    border-bottom:1px solid black;
    display:flex;
    justify-content: flex-end;
    background-color:white;
    position:relative;
    z-index:900;
    padding:3px 10px;
}
.myturn {
    /* background-color: red; */
}
.selectedGame {
    background-color: lightgray;
}
.myturnIcon {
    fill: red;
    width: 15px;
    top: 6px;
    position: absolute;
    right:10px;
}
#askparamsdiv {
    display: none;
}
.hcform {
    display: none;
    border: 2px solid gray;
    width: 600px;
    margin: 14px auto;
    padding: 14px 14px;
    border-radius: 8px;
    padding-bottom: 4px;
    background-color: lightgrey;
    z-index: 999;
    position: relative;
}
.icon {
    height: 26px;
    width: 26px;
}
#verbchooser {
    display: none;
}
.gamerow {
    position: relative;
    padding: 4px 6px;
    margin: 8px;
    cursor:pointer;
    color:blue;
}
SELECT, OPTION {
    /* font-family: WebNewAthenaUnicode,NewAthenaUnicode, helvetica,arial; */
}
.paramdiv {
    margin: 10px 4px;
    border-bottom: 4px solid white;
    padding-bottom: 4px;
}
.paramdivchanged {
    border-bottom: 4px solid red;
}

BUTTON {border-radius: 7px;}
a {color:blue;}

#refreshbutton {
    position: absolute;
    left: 7px;
    top: 3px;
}

@media only screen and (max-width: 800px) {
  .hcform {
    width:90%;
  }
}
#chat {
    position: absolute;
    top: 21px;
    right: 0px;
    display:none;
}
.myturnIcon { display:none; }
.myturn .myturnIcon { display:block; }

.startingform {border: 1px solid black;background-color:white}
#answerform {border: 1px solid black;background-color:white}

#changedesc b { border-bottom:3px solid red; padding-bottom:2px;}

.dark BODY { background-color: black;color:white; }
.dark .hcform { background-color: #202124;color:white; }
.dark .startingform {border: 1px solid white;background-color:black}
.dark #statusmesg {border-top: 1px solid white;}
.dark #list {border: 2px solid white;}
.dark #settings {border: 2px solid white;}
.dark #menubar { background-color: black;color:white;border-bottom: 1px solid white; }
.dark #answerform {background-color: black;color:white;border: 1px solid white;}
.dark #mfbutton {background-color: black;color:white;border: 1px solid white;}
.dark #mfbutton:disabled {background-color: black;color:#666;border: 1px solid white;}
.dark #submitbutton {background-color: black;color:white;border: 1px solid white;}
.dark .paramdiv {border-bottom: 4px solid transparent;}
.dark .paramdivchanged { border-bottom: 4px solid red;}
.dark a {color:#03A5F3;}
.dark .gamerow {color:#03A5F3;}
.dark .selectedGame {background-color: white;}
    </style>
    </head>
    <body onload="start()">
        <div id="menubar">
            <button id="refreshbutton" onclick="get_sessions()" style="display:none;">refresh</button>
            <div style="padding:0px 20px"><a id="loginlink" href="login">login</a>
                <span id="logoutlink" style="display:none;"><span id="username"></span> (<a href="logout">logout</a>)</span>
            </div>
            <div style="font-weight:bold;">HOPLITE CHALLENGE</div>
        </div>
        <div id="listouter" style="display:none;">
            <div id="settings">
                <table cellpadding="4" cellspacing="0">
                    <tr><td colspan="2">New Game</td></tr>
                    <tr><td>Top Unit:</td><td><input id="unitinput" type="text" value="20"/></td></tr>
                    <tr><td>Opponent:</td><td><input id="opponentinput" type="text"/></td></tr>
                    <tr><td align="center" colspan="2"><button id="creategamebutton" onclick="new_game_clicked()">Create Game</button></td></tr>
                </table>
            </div>
            <div id="list"></div>
        </div>

        <div class="hcform">
        <div class="hbox">
            <button id="mfbutton" class="mfbutton" onclick="mf_clicked()" title="Multiple Forms Button">MF</button>
            <div id="mainstopwatch">
                <div id="mainTime">
                    30:00
                </div>
            </div>
        </div>
    <div id="startingformouter" class="startingform">
        <div id="startingform" class=""></div>
        <select id="verbchooser">
        </select>
    </div>
    
    <div id="changedesc" class="changedesc"></div>

    <div id="askparamsdiv">
        <div id="askparamsdivinner">
            <div id="personparamdiv" class="paramdiv">
                <select id="personparam" onchange="select_changed(this)">
                    <option value="0">First</option>
                    <option value="1">Second</option>
                    <option value="2">Third</option>
                </select>
            </div>
            <div id="numberparamdiv" class="paramdiv">
                <select id="numberparam" onchange="select_changed(this)">
                    <option value="0">Singular</option>
                    <option value="1">Plural</option>
                </select>
            </div>
            <div id="tenseparamdiv" class="paramdiv">
                <select id="tenseparam" onchange="select_changed(this)">
                    <option value="0">Present</option>
                    <option value="1">Imperfect</option>
                    <option value="2">Future</option>
                    <option value="3">Aorist</option>
                    <option value="4">Perfect</option>
                    <option value="5">Pluperfect</option>
                </select>
            </div>
            <div id="moodparamdiv" class="paramdiv">
                <select id="moodparam" onchange="select_changed(this)">
                    <option value="0">Indicative</option>
                    <option value="1">Subjunctive</option>
                    <option value="2">Optative</option>
                    <option value="3">Imperative</option>
                </select>
            </div>
            <div id="voiceparamdiv" class="paramdiv">
                <select id="voiceparam" onchange="select_changed(this)">
                    <option value="0">Active</option>
                    <option value="1">Middle</option>
                    <option value="2">Passive</option>
                </select>
            </div>
        </div>
    </div>
    <textarea id="answerform" class="gkinput newform disablecopypaste" disabled autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" style="padding:10px;"></textarea>
    <div id="correctanswer" class="gkinput correctanswer" style="visibility: hidden;"></div>
    <button id="submitbutton" onclick="submit_clicked()">Start</button>
    <div id="statusmesg">press start to begin</div>
</div>
    <script>
    'use strict';

(function (global, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof module !== 'undefined' && module.exports){
        module.exports = factory();
    } else {
        global.ReconnectingWebSocket = factory();
    }
})(this, function () {

    if (!('WebSocket' in window)) {
        return;
    }

    function ReconnectingWebSocket(url, protocols, options) {

        // Default settings
        var settings = {

            /** Whether this instance should log debug messages. */
            debug: false,

            /** Whether or not the websocket should attempt to connect immediately upon instantiation. */
            automaticOpen: true,

            /** The number of milliseconds to delay before attempting to reconnect. */
            reconnectInterval: 1000,
            /** The maximum number of milliseconds to delay a reconnection attempt. */
            maxReconnectInterval: 30000,
            /** The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. */
            reconnectDecay: 1.5,

            /** The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. */
            timeoutInterval: 2000,

            /** The maximum number of reconnection attempts to make. Unlimited if null. */
            maxReconnectAttempts: null,

            /** The binary type, possible values 'blob' or 'arraybuffer', default 'blob'. */
            binaryType: 'blob'
        }
        if (!options) { options = {}; }

        // Overwrite and define settings with options if they exist.
        for (var key in settings) {
            if (typeof options[key] !== 'undefined') {
                this[key] = options[key];
            } else {
                this[key] = settings[key];
            }
        }

        // These should be treated as read-only properties

        /** The URL as resolved by the constructor. This is always an absolute URL. Read only. */
        this.url = url;

        /** The number of attempted reconnects since starting, or the last successful connection. Read only. */
        this.reconnectAttempts = 0;

        /**
         * The current state of the connection.
         * Can be one of: WebSocket.CONNECTING, WebSocket.OPEN, WebSocket.CLOSING, WebSocket.CLOSED
         * Read only.
         */
        this.readyState = WebSocket.CONNECTING;

        /**
         * A string indicating the name of the sub-protocol the server selected; this will be one of
         * the strings specified in the protocols parameter when creating the WebSocket object.
         * Read only.
         */
        this.protocol = null;

        // Private state variables

        var self = this;
        var ws;
        var forcedClose = false;
        var timedOut = false;
        var eventTarget = document.createElement('div');

        // Wire up "on*" properties as event handlers

        eventTarget.addEventListener('open',       function(event) { self.onopen(event); });
        eventTarget.addEventListener('close',      function(event) { self.onclose(event); });
        eventTarget.addEventListener('connecting', function(event) { self.onconnecting(event); });
        eventTarget.addEventListener('message',    function(event) { self.onmessage(event); });
        eventTarget.addEventListener('error',      function(event) { self.onerror(event); });

        // Expose the API required by EventTarget

        this.addEventListener = eventTarget.addEventListener.bind(eventTarget);
        this.removeEventListener = eventTarget.removeEventListener.bind(eventTarget);
        this.dispatchEvent = eventTarget.dispatchEvent.bind(eventTarget);

        /**
         * This function generates an event that is compatible with standard
         * compliant browsers and IE9 - IE11
         *
         * This will prevent the error:
         * Object doesn't support this action
         *
         * http://stackoverflow.com/questions/19345392/why-arent-my-parameters-getting-passed-through-to-a-dispatched-event/19345563#19345563
         * @param s String The name that the event should use
         * @param args Object an optional object that the event will use
         */
        function generateEvent(s, args) {
        	var evt = document.createEvent("CustomEvent");
        	evt.initCustomEvent(s, false, false, args);
        	return evt;
        };

        this.open = function (reconnectAttempt) {
            ws = new WebSocket(self.url, protocols || []);
            ws.binaryType = this.binaryType;

            if (reconnectAttempt) {
                if (this.maxReconnectAttempts && this.reconnectAttempts > this.maxReconnectAttempts) {
                    return;
                }
            } else {
                eventTarget.dispatchEvent(generateEvent('connecting'));
                this.reconnectAttempts = 0;
            }

            if (self.debug || ReconnectingWebSocket.debugAll) {
                console.debug('ReconnectingWebSocket', 'attempt-connect', self.url);
            }

            var localWs = ws;
            var timeout = setTimeout(function() {
                if (self.debug || ReconnectingWebSocket.debugAll) {
                    console.debug('ReconnectingWebSocket', 'connection-timeout', self.url);
                }
                timedOut = true;
                localWs.close();
                timedOut = false;
            }, self.timeoutInterval);

            ws.onopen = function(event) {
                clearTimeout(timeout);
                if (self.debug || ReconnectingWebSocket.debugAll) {
                    console.debug('ReconnectingWebSocket', 'onopen', self.url);
                }
                self.protocol = ws.protocol;
                self.readyState = WebSocket.OPEN;
                self.reconnectAttempts = 0;
                var e = generateEvent('open');
                e.isReconnect = reconnectAttempt;
                reconnectAttempt = false;
                eventTarget.dispatchEvent(e);
            };

            ws.onclose = function(event) {
                clearTimeout(timeout);
                ws = null;
                if (forcedClose) {
                    self.readyState = WebSocket.CLOSED;
                    eventTarget.dispatchEvent(generateEvent('close'));
                } else {
                    self.readyState = WebSocket.CONNECTING;
                    var e = generateEvent('connecting');
                    e.code = event.code;
                    e.reason = event.reason;
                    e.wasClean = event.wasClean;
                    eventTarget.dispatchEvent(e);
                    if (!reconnectAttempt && !timedOut) {
                        if (self.debug || ReconnectingWebSocket.debugAll) {
                            console.debug('ReconnectingWebSocket', 'onclose', self.url);
                        }
                        eventTarget.dispatchEvent(generateEvent('close'));
                    }

                    var timeout = self.reconnectInterval * Math.pow(self.reconnectDecay, self.reconnectAttempts);
                    setTimeout(function() {
                        self.reconnectAttempts++;
                        self.open(true);
                    }, timeout > self.maxReconnectInterval ? self.maxReconnectInterval : timeout);
                }
            };
            ws.onmessage = function(event) {
                if (self.debug || ReconnectingWebSocket.debugAll) {
                    console.debug('ReconnectingWebSocket', 'onmessage', self.url, event.data);
                }
                var e = generateEvent('message');
                e.data = event.data;
                eventTarget.dispatchEvent(e);
            };
            ws.onerror = function(event) {
                if (self.debug || ReconnectingWebSocket.debugAll) {
                    console.debug('ReconnectingWebSocket', 'onerror', self.url, event);
                }
                eventTarget.dispatchEvent(generateEvent('error'));
            };
        }

        // Whether or not to create a websocket upon instantiation
        if (this.automaticOpen == true) {
            this.open(false);
        }

        /**
         * Transmits data to the server over the WebSocket connection.
         *
         * @param data a text string, ArrayBuffer or Blob to send to the server.
         */
        this.send = function(data) {
            if (ws) {
                if (self.debug || ReconnectingWebSocket.debugAll) {
                    console.debug('ReconnectingWebSocket', 'send', self.url, data);
                }
                return ws.send(data);
            } else {
                throw 'INVALID_STATE_ERR : Pausing to reconnect websocket';
            }
        };

        /**
         * Closes the WebSocket connection or connection attempt, if any.
         * If the connection is already CLOSED, this method does nothing.
         */
        this.close = function(code, reason) {
            // Default CLOSE_NORMAL code
            if (typeof code == 'undefined') {
                code = 1000;
            }
            forcedClose = true;
            if (ws) {
                ws.close(code, reason);
            }
        };

        /**
         * Additional public API method to refresh the connection if still open (close, re-open).
         * For example, if the app suspects bad data / missed heart beats, it can try to refresh.
         */
        this.refresh = function() {
            if (ws) {
                ws.close();
            }
        };
    }

    /**
     * An event listener to be called when the WebSocket connection's readyState changes to OPEN;
     * this indicates that the connection is ready to send and receive data.
     */
    ReconnectingWebSocket.prototype.onopen = function(event) {};
    /** An event listener to be called when the WebSocket connection's readyState changes to CLOSED. */
    ReconnectingWebSocket.prototype.onclose = function(event) {};
    /** An event listener to be called when a connection begins being attempted. */
    ReconnectingWebSocket.prototype.onconnecting = function(event) {};
    /** An event listener to be called when a message is received from the server. */
    ReconnectingWebSocket.prototype.onmessage = function(event) {};
    /** An event listener to be called when an error occurs. */
    ReconnectingWebSocket.prototype.onerror = function(event) {};

    /**
     * Whether all instances of ReconnectingWebSocket should log debug messages.
     * Setting this to true is the equivalent of setting all instances of ReconnectingWebSocket.debug to true.
     */
    ReconnectingWebSocket.debugAll = false;

    ReconnectingWebSocket.CONNECTING = WebSocket.CONNECTING;
    ReconnectingWebSocket.OPEN = WebSocket.OPEN;
    ReconnectingWebSocket.CLOSING = WebSocket.CLOSING;
    ReconnectingWebSocket.CLOSED = WebSocket.CLOSED;

    return ReconnectingWebSocket;
});

    let global_username = null;
    let global_timer_intv = null;
    let global_countDownDate = null;
    let global_timerRunning = false;
    let global_starting_form = null;
    let global_change_desc = null;
    let global_max_changes = null;
    let global_show_correct = false;
    let global_practice = false;
    let global_session_state = null;
    let global_session_id = null;
    let global_mf_pressed = false;
    let global_timed_out = false;
    let global_seconds = 30;
    let global_timer_ref = null;
    let unicodeMode = 0;
    let myturnIcon = `<svg class="myturnIcon" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><circle cx="50" cy="50" r="50" /></svg>`;
    let correctIcon = `<svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" enable-background="new 0 0 64 64"><path d="M32,2C15.431,2,2,15.432,2,32c0,16.568,13.432,30,30,30c16.568,0,30-13.432,30-30C62,15.432,48.568,2,32,2z M25.025,50  l-0.02-0.02L24.988,50L11,35.6l7.029-7.164l6.977,7.184l21-21.619L53,21.199L25.025,50z" fill="#43a047"/></svg>`;
    let incorrectIcon = `<svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" enable-background="new 0 0 64 64"><path d="m32 2c-16.568 0-30 13.432-30 30s13.432 30 30 30 30-13.432 30-30-13.432-30-30-30m5.513 44.508l-5.514-9.894-5.825 9.894h-7.048l9.331-14.783-8.878-14.232h7.244l5.175 9.449 5.317-9.449h7.008l-8.878 13.996 9.429 15.02h-7.361z" fill="#e53935"/></svg>`;
    // Check for wasm support.
	if (!('WebAssembly' in window)) {
		alert('you need a browser with wasm support enabled :(');
	}

    function select_changed(s) {
        let changed_nodes = document.querySelectorAll(".paramdivchanged");
        if (changed_nodes && global_max_changes !== null && changed_nodes.length >= global_max_changes 
            && s.value != s.getAttribute("orig") 
            && !s.parentNode.classList.contains("paramdivchanged")) {
            s.value = s.getAttribute("orig");
        }

        if (s.value != s.getAttribute("orig") && global_max_changes !== null) {
            s.parentNode.classList.add("paramdivchanged");
        }
        else {
            s.parentNode.classList.remove("paramdivchanged");
        }
    }
	
	function loadWebAssembly(filename, imports) {
		return fetch(filename)
		.then(response => response.arrayBuffer())
		.then(buffer => WebAssembly.compile(buffer))
		.then(module => {
			return WebAssembly.instantiate(module);
		});
	}
	
	let wasmBuffer0;
	let accentSyllableWASM;
	let transliterateWASM;
	let wasmBufferLength = 256;
	let memory;
	loadWebAssembly('hoplitekb.wasm', { js: { mem: memory } })
		.then(instance => {
			let exports = instance.exports;
			accentSyllableWASM = exports.accentSyllable2;
			transliterateWASM = exports.transliterate;
			memory = exports.memory;
	
			//console.log("memory: " + memory.buffer.byteLength);
	
			//https://rob-blackbourn.github.io/blog/webassembly/wasm/array/arrays/javascript/c/2020/06/07/wasm-arrays.html
			//offset is in bytes, length is in array elements
			//https://stackoverflow.com/questions/15417310/why-typed-array-constructors-require-offset-to-be-multiple-of-underlying-type-si
			let offset = 2; //don't set start at zero (null), use 2 for proper alignment
			wasmBuffer0 = new Uint16Array(memory.buffer, offset, wasmBufferLength);
			//console.log("offset0: " + offset + ", " + wasmBuffer0.byteOffset + ", " + wasmBuffer0.length);
		}
	);
	
	function strToCodePoints(str) {
		let a = "";
		for (let i = 0; i < str.length; i++) {
			a += str.codePointAt(i).toString(16).padStart(4,"0").toUpperCase() + " ";
		}
		return a.trim();
	}

    const supportsWebSockets = 'WebSocket' in window || 'MozWebSocket' in window;
    function start() {
        global_timer_ref = q('#mainTime');
	    const supported = (() => {
            try {
                if (typeof WebAssembly === "object"
                    && typeof WebAssembly.instantiate === "function") {
                    const module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));
                    if (module instanceof WebAssembly.Module)
                        return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;
                }
            } catch (e) { }
            return false;
        })();
	    //console.log(supported ? "WebAssembly is supported" : "WebAssembly is not supported");
	
        //block pasting
        let answerform = q("#answerform");
        answerform.addEventListener('paste', (event) => {
            event.preventDefault();
        });

        answerform.addEventListener('keypress', handleKey, false);
        //$(".gkinput").keypress(handleKey);

        global_session_id = localStorage.getItem("selected_session_id");
        if (supportsWebSockets) {
            wsconnect();
        }
        // else {
        //     get_sessions();
        // }
        console.log(getTextWidth("παιδεύσητε", "normal 24pt WebNewAthenaUnicode"));  // close to 86
	}

function getTextWidth(text, font) {
  // re-use canvas object for better performance
  const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement("canvas"));
  const context = canvas.getContext("2d");
  context.font = font;
  const metrics = context.measureText(text);
  return metrics.width;
}

// function getCssStyle(element, prop) {
//     return window.getComputedStyle(element, null).getPropertyValue(prop);
// }

// function getCanvasFont(el = document.body) {
//   const fontWeight = getCssStyle(el, 'font-weight') || 'normal';
//   const fontSize = getCssStyle(el, 'font-size') || '16px';
//   const fontFamily = getCssStyle(el, 'font-family') || 'Times New Roman';
  
//   return `${fontWeight} ${fontSize} ${fontFamily}`;
// }


	
	function accentSyllable(origChars, key) {
		let len = origChars.length;
		//add letter and any combining diacritics to the buffer as code points
		for (let i = 0; i < len && i < wasmBufferLength; i++) {
			wasmBuffer0[i] = origChars.codePointAt(i);
			//console.log("accent1: " + origChars.codePointAt(i));
		}
		//console.log("accent1a: " + len + ", " + key);
		len = accentSyllableWASM(wasmBuffer0.byteOffset, len, key, 1, parseInt(unicodeMode) );
	
		//transform the returned code points back to a string
		let newLetter = "";
		for (let i = 0; i < len && i < wasmBufferLength; i++) {
			newLetter += String.fromCodePoint(wasmBuffer0[i]);
			//console.log("accent2: " + String.fromCodePoint(wasmBuffer0[i]));
		}
		/*
		for (let i = 0; i < 10; i++) {
			wasmBuffer0[i] = 0;
		}*/
		//console.log("ptr2: " + wasmBuffer0.byteOffset + ", " + wasmBuffer0.length);
		//let win1251decoder = new TextDecoder('utf-16le');
		return newLetter;
	}
	
	function handleKey(e) {
		let val = this.value;
        
        let charCode = typeof(e.which) == "number" ? e.which : e.keyCode;
		if (typeof(this.selectionStart) == "number" && typeof(this.selectionEnd) == "number") {
			let start = this.selectionStart;
			let end = this.selectionEnd;
			let newLetter = "";
			let replacing = 0;
			
			let key = String.fromCharCode(charCode);
	
            if (charCode && charCode == 13) { //enter key
                submit_clicked();
                return false;
            }
			else if (charCode && charCode > 64 && charCode < 123) //transliterate letter
			{
				//newLetter = accentSyllable("", key.codePointAt(0));
				newLetter = String.fromCharCode( transliterateWASM( key.codePointAt(0) ) );
				//console.log("new: " + newLetter);
			}
			else if (charCode && charCode > 47 && charCode < 58) //number: 0-9 are 48-57
			{ 
                //console.log("handlekey2: " + charCode + ", " + val.length);
				//underdot,rough,smooth,acute,grave,circ,macron,breve,iotasub,diaeresis
				const diacriticKeys = [11,5,6,1,3,2,4,10,7,9];
				let hckey = diacriticKeys[ parseInt(key) ];
	
				const combining = [0x0300, 0x0301, 0x0304, 0x0306, 0x0308, 0x0313, 0x0314, 0x0323, 0x0342, 0x0345];
				let offset = 1;
				for (let i = start; i > -1; i--) {
					if (combining.indexOf(val.codePointAt(i - 1)) > -1) {
						offset++;
					}
					else {
						break;
					}
				}
	
				unicodeMode = 0;
	
				newLetter = accentSyllable(val.slice(start - offset, start), hckey);
				replacing = start - (start - offset);
			}
	
			if (newLetter.length > 0) {
				//update the input/textarea
				this.value = val.slice(0, start - replacing) + newLetter + val.slice(end);
				// Move the caret
				this.selectionStart = this.selectionEnd = (start - replacing) + newLetter.length;
                //e.stopPropagation();
                e.preventDefault(); //called by default when keypress is attached with jquery and returning false
				return false;
			}
		}
        if (charCode && charCode > 47 && charCode < 58) {
            e.stopPropagation();
            e.preventDefault();
        }
		return true; //this allows most punctuation to pass through
	}
    
    //https://github.com/le717/microajax
    function microAjax(options) {
      "use strict";

      // Default to GET
      if (!options.method) {
        options.method = "GET";
      }

      // Default empty functions for the callbacks
      function noop() {}
      if (!options.success) {
        options.success = noop;
      }
      if (!options.warning) {
        options.warning = noop;
      }
      if (!options.error) {
        options.error = noop;
      }

      let request = new XMLHttpRequest();
      request.open(options.method, options.url, true);
      //request.setRequestHeader('Content-type', 'application/json; charset=UTF-8')
      request.setRequestHeader('Content-type', 'application/x-www-form-urlencoded; charset=UTF-8')
      request.send(options.data);

      request.onload = function() {
        // Success!
        if (request.readyState === 4 && request.status === 200) {
          options.success(JSON.parse(request.responseText));

          // We reached our target destination, but it returned an error
        } else {
          options.warning(request.responseText);
        }
      };

      // There was a connection error of some sort
      request.onerror = options.error;
    }

    function procResponseError(data) {
        console.log(data);
    }

    function procResponse(data) {
        console.log(data);

        // if (handle_response !== null) {
        //     handle_response(data);
        // }
        // else 
        if (data.response_to == "ask" && data.success) {
            get_sessions();
            uiModeAskResponse(data);
        }
        else if ((data.response_to == "answerresponse" || data.response_to == "answerresponsepractice") && data.success) {
            get_sessions();
            global_starting_form = data.starting_form;
            global_change_desc = data.change_desc;
            uiModeAnswerResponseReceived(data);
        }
        else if ((data.response_to == "mfpressedresponse" || data.response_to == "mfpressedresponsepractice") && data.success) {
            if (data.is_correct == false) {
                uiModeClickedEnter();
            
                global_starting_form = data.starting_form;
                global_change_desc = data.change_desc;
                uiModeAnswerResponseReceived(data);
            }
        }
        else if (data.response_to == "newsession" && data.success) {
            get_sessions();
        }
        else if (data.response_to == "getmoves" && data.success) {
            if (data.myturn && data.move_type != "Practice") {
                q(".gamerow[data-uuid='" + data.session_id + "']").classList.add("myturn");
            }
            else {
                q(".gamerow[data-uuid='" + data.session_id + "']").classList.remove("myturn");
            }
            setUI(data);
        }
        else if (data.response_to == "getsessions" && data.success) {
            if (data.username) {
                q("#loginlink").style.display = "none";
                q("#logoutlink").style.display = "inline";
                q("#username").innerText = data.username;
                global_username = data.username;
            }
            else {
                q("#loginlink").style.display = "inline";
                q("#logoutlink").style.display = "none";
                q("#username").innerText = "";
                global_username = null;
            }

            let rows = "";
            for (let i = 0; i < data.sessions.length; i++) {
                let s = data.sessions[i];
                if (s.move_type != "FirstMoveTheirTurn") /* do not show if first move not asked yet and I did not start game */ {
                    rows += "<div data-uuid='" + s.session_id +"' ";
                    rows += "class='gamerow" + (s.myturn && s.move_type != "Practice" ? " myturn" : "");
                    rows += (s.session_id == global_session_id ? " selectedGame" : "") + "' ";
                    rows += (s.opponent_name ? "opponent='" + s.opponent_name + "' " : "");
                    rows += "title='" + s.move_type + "' ";
                    rows += "onclick='get_move(this)'>";
                    rows += (s.move_type == "Practice" ? "Practice" : (global_username ? global_username : "Game"));
                    rows += (s.opponent_name ? " vs. " + s.opponent_name : "");
                    rows += (s.move_type != "Practice" ? (" (" + s.my_score + " - " + s.their_score + ")") : "");
                    rows += myturnIcon + "</div>";
                }
                //q(".gamerow[data-uuid='b72df91e-3a4c-4f1b-aeda-c14fea61def6']").style.backgroundColor = "blue";
            }
            q("#list").innerHTML = rows;
            q("#refreshbutton").style.display = "block";
            q("#listouter").style.display = "block";

            if (data.current_session) {
                setUI(data.current_session);
            }
        }
    }

    function serialize(obj) {
        let str = [];
        for (let p in obj)
        if (obj.hasOwnProperty(p)) {
            str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
        }
        return str.join("&");
    }

    let pending_send_data = null;
    function generic_send_request(send_url, send_data, handle_response) {
        // if (supportsWebSockets && !socket) {
        //     wsconnect(send_url, send_data);
        //     return;
        // }
 
        if (socket) {
            console.log("websocket request");
            send_data = JSON.stringify(send_data);
            socket.send(send_data);
        }
        else {
            console.log("ws not connected: can't send.");
            /*
            pending_send_data = send_data;
            wsconnect();
            */

            // console.log("http request");
            // send_data = serialize(send_data);
            // microAjax({
            //     url: send_url,
            //     method: "POST",
            //     data: send_data,
            //     success: procResponse,
            //     warning: procResponseError,
            //     error: null
            // });
        }

        // $.ajax({
        //     url: send_url,
        //     type: "POST",
        //     data: send_data,
        //     dataType: "json",
        //     success: function (data, textStatus, jqXHR) {
        //          procResponse(data);
        //     },
        //     error: function(response) {
        //         console.log("error: " + response);
        //     }
        // });
    }

    function send_ask(session_id, person, number, tense, mood, voice, verb_id) {
        let send_data = {qtype:"ask", session_id: session_id, person: parseInt(person), number: parseInt(number), tense: parseInt(tense), mood: parseInt(mood), voice: parseInt(voice), verb: parseInt(verb_id)};
        generic_send_request("ask", send_data, null);
    }

    function send_answer(session_id, answer, time, mfPressed, timedOut) {
        let send_data = {qtype:"submit", answer:answer, time:time, mf_pressed:mfPressed, timed_out:timedOut, session_id: session_id};
        generic_send_request("enter", send_data, null);
    }

    function send_mf(session_id, answer, time, mfPressed, timedOut) {
        let send_data = {qtype:"mfpressed", answer:answer, time:time, mf_pressed:mfPressed, timed_out:timedOut, session_id: session_id};
        generic_send_request("mf", send_data, null);
    }

    function new_game_clicked() {
        let unitv = q("#unitinput").value.trim();
        let opponentv = q("#opponentinput").value.trim();

        let send_data = {qtype:"newsession", unit:unitv, opponent:opponentv,practice_reps_per_verb:4};
        generic_send_request("new", send_data, null);
    }

    function submit_clicked() {
        let submitbutton = q("#submitbutton");
        if (submitbutton.innerText == "Enter") {
            uiModeClickedEnter();

            let answer = q("#answerform").value.trim();
            let time = q("#mainTime").innerText.trim();
            console.log("Enter clicked: " + answer + ", time: " + time + ", mfPressed: " + global_mf_pressed + ", timedout: " + global_timed_out);
        
            send_answer(global_session_id, answer, time, global_mf_pressed, global_timed_out);
        }
        else if (submitbutton.innerText == "Continue" || submitbutton.innerText == "Start") {
            console.log(submitbutton.innerText + " clicked");
            uiModeAskForm2();
        }
        else if (submitbutton.innerText == "Ask") {
            let vals = get_param_values();
            if (document.querySelectorAll(".paramdivchanged").length > 0 || 
                q("#verbchooser").style.display != "none") {
                send_ask(global_session_id, vals[0], vals[1], vals[2], vals[3], vals[4], vals[5]);
            }
            else {
                alert("you must change at least one parameter");
            }
        }
        else if (submitbutton.innerText == "Go") {
            console.log(submitbutton.innerText + " clicked");
            uiModeAnwerGoForm(global_starting_form, global_change_desc);
        }
    }

    function mf_clicked() {
        console.log("multiple forms clicked");
        if (!global_mf_pressed) { //only allow clicking this once
            q("#mfbutton").disabled = true;

            add_seconds_to_time(global_seconds / 2);
            global_mf_pressed = true;

            let answer = q("#answerform").value.trim();
            let time = q("#mainTime").innerText.trim();
            console.log("MF clicked: " + answer + ", time: " + time + ", mfPressed: " + global_mf_pressed + ", timedout: " + global_timed_out);

            send_mf(global_session_id, answer, time, global_mf_pressed, global_timed_out);
        }
    }

    function timeout() {
        console.log("timed out");
        clearInterval(global_timer_intv);
        global_timed_out = true;
        global_timer_ref.innerHTML = "<span style=\"color:red;font-weight:bold;\">00:00</span>";
        submit_clicked();
    }
    
    function get_move(thisrow) {
        document.querySelectorAll(".selectedGame").forEach((row) => {
            row.classList.remove("selectedGame");
        });        
        thisrow.classList.add("selectedGame");

        global_session_id = thisrow.getAttribute("data-uuid");
        localStorage.setItem("selected_session_id", global_session_id);

        let send_data = { qtype: "getmove", session_id: global_session_id };
        generic_send_request("getmove", send_data, null);
    }

    function get_sessions() {
        let send_data = { qtype:"getsessions", current_session: global_session_id };
        generic_send_request("list", send_data, null);
    }

    function set_params_dropdowns(person, number, tense, voice, mood, verb_id) {
        let a = document.querySelectorAll(".paramdivchanged").forEach(e => e.classList.remove("paramdivchanged"));

        let p = q("#personparam");
        p.value = person;
        p.setAttribute("orig", person);
        let n = q("#numberparam");
        n.value = number;
        n.setAttribute("orig", number);
        let t = q("#tenseparam");
        t.value = tense;
        t.setAttribute("orig", tense);
        let m = q("#moodparam");
        m.value = mood;
        m.setAttribute("orig", mood);
        let v = q("#voiceparam");
        v.value = voice;
        v.setAttribute("orig", voice);
        let vc = q("#verbchooser");
        //if the dropdown doesn't have enough rows to assign value, just add a new row for it. it's ok: we can't see it
        if (verb_id >= vc.options.length && vc.value != verb_id /* so we don't get two of same option */) {
            let o = document.createElement("option");
            o.value = verb_id;
            o.text = "";
            vc.add(o);
        }
        vc.value = verb_id;
    }

    function get_param_values() {
        let p = q("#personparam").value;
        let n = q("#numberparam").value;
        let t = q("#tenseparam").value;
        let m = q("#moodparam").value;
        let v = q("#voiceparam").value;
        let verb_id = q("#verbchooser").value;

        //console.log("vals: " + p + n + t + m + v + verb_id);
        return [p,n,t,m,v,verb_id];
    }

    function setUI(data) {
        global_practice = false;
        q(".hcform").style.display = "block";
        switch(data.move_type) {
            case "Practice": 
                uiModePractice(data); //practice
                break;
            case "FirstMoveMyTurn": 
                uiModeAskForm(data, 5); //I need to ask first move
                break;
            case "FirstMoveTheirTurn": 
                uiModeWaitingForAsk(data); //no moves: waiting for other player to ask first move
                break;
            case "AnswerMyTurn": 
                uiModeAnwerForm(data); //I need to answer
                break;
            case "AskTheirTurn":     
                uiModeWaitingForAsk(data); //waiting for you to ask
                break;
            case "AskMyTurn": 
                uiModeAskForm(data, 2); //I need to ask
                break;
            case "AnswerTheirTurn": 
                uiModeWaitingForAnswer(data); //waiting for you to answer
                break;
            case "GameOver": 
                uiModeGameIsOver(); //game has ended
                break;
            default:
                break;
        }
    }

    const persons = ["first", "second", "third"];
    const numbers = ["singular", "plural"];
    const tenses = ["present", "imperfect", "future", "aorist", "perfect", "pluperfect"];
    const voices  = ["active", "middle", "passive"];
    const moods = ["indicative", "subjunctive", "optative", "imperative"];
    function desc(person, number, tense, mood, voice, prevp, prevn, prevt, prevm, prevv) {
        if (person !== prevp && prevp !== null) {
            person = "<b>" + persons[person] + "</b>";
        }
        else {
            person = persons[person];
        }
        if (number !== prevn && prevn !== null) {
            number = "<b>" + numbers[number] + "</b>";
        }
        else {
            number = numbers[number];
        }
        if (tense !== prevt && prevt !== null) {
            tense = "<b>" + tenses[tense] + "</b>";
        }
        else {
            tense = tenses[tense];
        }
        if (mood !== prevm && prevm !== null) {
            mood = "<b>" + moods[mood] + "</b>";
        }
        else {
            mood = moods[mood];
        }
        if (voice !== prevv && prevv !== null) {
            voice = "<b>" + voices[voice] + "</b>";
        }
        else {
            voice = voices[voice];
        }
        return person + " " + number + " " + tense + " " + mood + " " + voice;
    }

    function uiModeGameIsOver() {
        let submitbutton = q("#submitbutton");
        submitbutton.disabled = true;
        q("#statusmesg").innerHTML = "Game is over.";
        q("#answerform").value = "";
        q("#answerform").disabled = true;
        q("#correctanswer").innerHTML = "";
        q("#correctanswer").style.visibility = "hidden";
        q("#startingform").innerText = "";
        q("#mfbutton").disabled = true;
        q("#verbchooser").style.display = "none";
    }

    //need to set prev params for first form
    function uiModePractice(data) {
        let submitbutton = q("#submitbutton");
        submitbutton.disabled = false;
        submitbutton.innerText = "Go";
        global_starting_form = data.starting_form;
        global_change_desc = desc(data.person, data.number, data.tense, data.mood, data.voice, data.person_prev, data.number_prev, data.tense_prev, data.mood_prev, data.voice_prev);
        //q("#statusmesg").innerHTML = "Click Go to answer!"
        q("#statusmesg").innerHTML = "Practice Mode";
        q("#changedesc").innerHTML = (data.person_prev !== null) ? desc(data.person_prev, data.number_prev, data.tense_prev, data.mood_prev, data.voice_prev, null, null, null, null, null) : "";
        q("#answerform").value = "";
        q("#answerform").disabled = true;
        q("#mfbutton").disabled = true;
        q("#correctanswer").innerHTML = "";
        q("#correctanswer").style.visibility = "hidden";
        q("#startingform").innerText = (data.starting_form) ? data.starting_form : "";

        q("#askparamsdiv").style.display = "none";
        q("#submitbutton").style.display = "block";
        q("#verbchooser").style.display = "none";
    }

    function uiModeAnwerForm(data) {
        let submitbutton = q("#submitbutton");
        submitbutton.disabled = false;
        submitbutton.innerText = "Go";
        global_starting_form = data.starting_form;
        global_change_desc = desc(data.person, data.number, data.tense, data.mood, data.voice, data.person_prev, data.number_prev, data.tense_prev, data.mood_prev, data.voice_prev);
        q("#statusmesg").innerHTML = "Click Go to answer!"
        q("#changedesc").innerHTML = (data.person_prev !== null) ? desc(data.person_prev, data.number_prev, data.tense_prev, data.mood_prev, data.voice_prev, null, null, null, null, null) : "";
        q("#answerform").value = "";
        q("#answerform").disabled = true;
        q("#mfbutton").disabled = true;
        q("#correctanswer").innerHTML = "";
        q("#correctanswer").style.visibility = "hidden";
        q("#startingform").innerText = (data.starting_form) ? data.starting_form : "";

        q("#askparamsdiv").style.display = "none";
        q("#submitbutton").style.display = "block";
        q("#verbchooser").style.display = "none";
    }

    function uiModeAnwerGoForm(loc_starting_form, loc_change_desc) {
        let submitbutton = q("#submitbutton");
        submitbutton.disabled = false;
        submitbutton.innerText = "Enter";
        global_mf_pressed = false;
        
        q("#statusmesg").innerHTML = "Click enter to submit!"
        q("#changedesc").innerHTML = loc_change_desc;
        q("#answerform").value = "";
        q("#answerform").disabled = false;
        q("#mfbutton").disabled = false;
        q("#answerform").focus();
        q("#correctanswer").innerHTML = "";
        q("#correctanswer").style.visibility = "hidden";
        q("#startingform").innerText = loc_starting_form;

        q("#askparamsdiv").style.display = "none";
        startTimer();
        q("#submitbutton").style.display = "block";
        q("#verbchooser").style.display = "none";
    }

    function uiModeWaitingForAnswer(data) {
        let submitbutton = q("#submitbutton");
        submitbutton.disabled = true;
        q("#statusmesg").innerHTML = "Waiting for opponent to answer.";
        q("#answerform").value = "";
        q("#answerform").disabled = true;
        q("#correctanswer").innerHTML = "";
        q("#correctanswer").style.visibility = "hidden";
        q("#startingform").innerText = data.starting_form;

        q("#askparamsdiv").style.display = "none";

        q("#changedesc").innerHTML = desc(data.person, data.number, data.tense, data.mood, data.voice, data.person_prev, data.number_prev, data.tense_prev, data.mood_prev, data.voice_prev);
        q("#submitbutton").style.display = "none";
        q("#mfbutton").disabled = true;
        q("#mainTime").innerText = "30:00";
        q("#verbchooser").style.display = "none";
    }

    function uiModeWaitingForAsk(data) {
        let submitbutton = q("#submitbutton");
        submitbutton.disabled = true;
        q("#statusmesg").innerHTML = "Waiting for opponent to ask.";
        q("#answerform").value = data.answer;
        q("#answerform").disabled = true;
        
        q("#correctanswer").style.visibility = "visible";
        q("#startingform").innerText = data.starting_form;
        
        q("#mainTime").innerText = data.time;
        q("#askparamsdiv").style.display = "none";
        q("#submitbutton").style.display = "none";
        q("#mfbutton").disabled = true;

        if (data.move_type == "FirstMoveTheirTurn") {
            q("#changedesc").innerHTML = "";
            q("#correctanswer").innerHTML = "";
        }
        else {
            q("#changedesc").innerHTML = desc(data.person, data.number, data.tense, data.mood, data.voice, data.person_prev, data.number_prev, data.tense_prev, data.mood_prev, data.voice_prev);
            q("#correctanswer").innerHTML = ((data.is_correct) ? correctIcon : incorrectIcon) + " " + ((!data.is_correct || global_show_correct) ? data.correct_answer : "");

        }
        q("#verbchooser").style.display = "none";
    }

    function uiModeAskResponse(data) {
        console.log("ask successfully submitted");
        q("#mfbutton").disabled = true;
        let submitbutton = q("#submitbutton");
        submitbutton.innerText = "Sent!";
        q("#statusmesg").innerHTML = "Sent!";
        submitbutton.disabled = true;
        q("#askparamsdiv").style.display = "none";
        q("#verbchooser").style.display = "none";
        if (data.starting_form) {
            q("#startingform").innerText = data.starting_form;
        }
        q("#changedesc").innerHTML = desc(data.person, data.number, data.tense, data.mood, data.voice, data.person_prev, data.number_prev, data.tense_prev, data.mood_prev, data.voice_prev);
    }

    function uiModeAskForm(data, max_params_to_change) {
        global_session_state = data;
        set_params_dropdowns(data.person, data.number, data.tense, data.voice, data.mood, data.verb);

        if (data.move_type == "FirstMoveMyTurn") {
            uiModeAskForm2();
            return;
        }

        q("#mfbutton").disabled = true;
        let submitbutton = q("#submitbutton");
        if (data.move_type == "Practice") {
            submitbutton.innerText = "Ask";
            q("#verbchooser").style.display = "none";
            q("#askparamsdiv").style.display = "block";
            q("#statusmesg").innerHTML = "Click ask to ask this form."
            q("#startingform").innerText = "";
            q("#changedesc").innerHTML = "";
            q("#answerform").value = "";
            q("#correctanswer").style.visibility = "hidden";
            q("#correctanswer").innerHTML = "";
        }
        else {
            submitbutton.innerText = "Continue";
            q("#verbchooser").style.display = "none";
            q("#mainTime").innerText = data.time;
            q("#askparamsdiv").style.display = "none";
            q("#statusmesg").innerHTML = "Click Continue to ask the next form."
            q("#startingform").innerText = data.starting_form;
            q("#changedesc").innerHTML = desc(data.person, data.number, data.tense, data.mood, data.voice, data.person_prev, data.number_prev, data.tense_prev, data.mood_prev, data.voice_prev);
            q("#answerform").value = data.answer;
            q("#correctanswer").style.visibility = "visible";
            q("#correctanswer").innerHTML = ((data.is_correct) ? correctIcon : incorrectIcon) + " " + ((!data.is_correct || global_show_correct) ? data.correct_answer : "");
        }
        submitbutton.style.display = "block";
        submitbutton.disabled = false;
    }

    function uiModeAskForm2() {
        let data = global_session_state;
        global_session_state = null;
        
        let submitbutton = q("#submitbutton");
        submitbutton.innerText = "Ask";
        submitbutton.style.display = "block";
        submitbutton.disabled = false;
        q("#mfbutton").disabled = true;
        if (data.move_type == "FirstMoveMyTurn") {
            global_max_changes = null; //can change all
            set_params_dropdowns(null, null, null, null, null, null);
            let verbchooser = q("#verbchooser");
            //remove verb options
            while (verbchooser.options.length > 0) {                
                verbchooser.remove(0);
            }
            //add new verb options
            for (let v = 0; v < data.verbs.length; v++) {
                let o = document.createElement("option");
                o.value = data.verbs[v].id;
                o.text = data.verbs[v].verb;
                verbchooser.add(o);
            }
            verbchooser.value = null;
        
            q("#startingform").innerText = "";
            verbchooser.style.display = "inline-block";
            q("#statusmesg").innerHTML = "Choose a verb and set all parameters";
        }
        else {
            global_max_changes = 2;
            set_params_dropdowns(data.person, data.number, data.tense, data.voice, data.mood, data.verb);
            q("#startingform").innerText = data.correct_answer;
            q("#verbchooser").style.display = "none";
            q("#statusmesg").innerHTML = "Change up to (2) parameters";
        }
        q("#mainTime").innerHTML = "30:00";
        q("#askparamsdiv").style.display = "block";
        q("#changedesc").innerHTML = "";//desc(data.person, data.number, data.tense, data.mood, data.voice, data.person_prev, data.number_prev, data.tense_prev, data.mood_prev, data.voice_prev);
        //q("#changedesc").style.display = "none";
        q("#answerform").value = "";
        q("#correctanswer").style.visibility = "hidden";
        q("#correctanswer").innerHTML = ((data.is_correct) ? correctIcon : incorrectIcon) + " " + ((!data.is_correct || global_show_correct) ? data.correct_answer : "");

        //q("#statusmesg").innerHTML = "Click Ask to ask the next form."
        // if (max_params_to_change == 5) {
        //     q("#statusmesg").innerHTML = "Choose a verb and set all params.";
        // }
        // else {
        //     q("#statusmesg").innerHTML = "Change up to (" + max_params_to_change + ") params.";
        // }

    }
    function uiModeClickedEnter() {
        let submitbutton = q("#submitbutton");
        submitbutton.innerText = "Loading...";
        submitbutton.disabled = true;
        stopTimer();
        q("#answerform").disabled = true;
    }

    function uiModeAnswerResponseReceived(data) {
        let submitbutton = q("#submitbutton");
        if (data.move_type == "Practice") {
            submitbutton.innerText = "Go";
            global_practice = true;
            global_starting_form = data.starting_form;
            global_change_desc = desc(data.person, data.number, data.tense, data.mood, data.voice, data.person_prev, data.number_prev, data.tense_prev, data.mood_prev, data.voice_prev);
            q("#statusmesg").innerHTML = "Click Go to answer the next form."
        }
        else {
            global_practice = false;
            submitbutton.innerText = "Continue";
            q("#statusmesg").innerHTML = "Click Continue to ask the next form."
        }
        global_session_state = data;
        submitbutton.disabled = false;
        submitbutton.focus();
        q("#mfbutton").disabled = true;
        //mark (in)correct, show correct answer
        q("#correctanswer").style.visibility = "visible";
        q("#correctanswer").innerHTML = ((data.is_correct) ? correctIcon : incorrectIcon) + " " + ((!data.is_correct || global_show_correct) ? data.correct_answer : "");
    }

    function add_seconds_to_time(secs) {
        global_countDownDate += (secs * 1000);
    }
    function startTimer() {
        global_timed_out = false;
        global_countDownDate = new Date().getTime() + (global_seconds * 1000);
        global_timer_intv = setInterval(interval_func, 10);
        global_timerRunning = true;
    }
    function stopTimer() {
        clearInterval(global_timer_intv);
        global_timer_intv = null;
        global_timerRunning = false;
    }
    function interval_func() {
        let now = new Date().getTime();
        let distance = global_countDownDate - now;

        if (distance <= 0) {
            timeout();
            return;
        }

        //let days = Math.floor(distance / (1000 * 60 * 60 * 24));
        //let hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        let minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
        let seconds = Math.floor((distance % (1000 * 60)) / 1000);
        let ms = Math.floor((distance % (1000)) / 10);

        global_timer_ref.innerHTML = ((minutes > 0) ? ((minutes < 10) ? ("0" + minutes + ":") : minutes + ":") : "") + ((seconds < 10) ? ("0" + seconds + ":") : seconds + ":") + ((ms < 10) ? ("0" + ms) : ms);
    }

    //   const $status = q('#status')
    //   const $connectButton = q('#connect')
    //   const $log = q('#log')
    //   const $form = q('#chatform')
    //   const $input = q('#text')

      /** @type {WebSocket | null} */
      var socket = null

    //   function log(msg, type = 'status') {
    //     $log.innerHTML += `<p class="msg msg--${type}">${msg}</p>`
    //     $log.scrollTop += 1000
    //   }

    let visibilityCheck = false;
      function wsconnect() {
        //wsdisconnect()

        const { location } = window;

        const proto = location.protocol.startsWith('https') ? 'wss' : 'ws';
        const wsUri = `${proto}://${location.host}/ws`;

        //log('Connecting...')
        //socket = new WebSocket(wsUri);
        socket = null;
        socket = new ReconnectingWebSocket(wsUri, null, {debug: true});

        socket.onopen = () => {
            console.log("ws connected");
            //log('Connected')
            updateConnectionStatus();
            /*
            if (pending_send_data) {
                generic_send_request(null, pending_send_data, null);
                pending_send_data = null;
            }
            if (!visibilityCheck) {
                //https://stackoverflow.com/questions/1060008/is-there-a-way-to-detect-if-a-browser-window-is-not-currently-active
                document.addEventListener("visibilitychange", onchange);
                function onchange (evt) {
                    if (document.hidden) {
                        console.log("document hidden");
                    }
                    else {
                        console.log("document visible");
                        if (!socket) {
                            wsconnect();
                        }
                    }
                }
                visibilityCheck = true;
            }*/
        }

        socket.onmessage = (ev) => {
          console.log("websocket data received");// + ev.data);
          try {
            let json = JSON.parse(ev.data);
            procResponse(json);
          }
          catch(e) { console.log(e.message) }
        }

        socket.onclose = () => {
          console.log("ws disconnected");
          //socket = null
          //updateConnectionStatus()
        }
      }

    //   function try_ws_reconnect() {
    //     if (!socket) {
    //         wsconnect();
    //         //setTimeout(try_ws_reconnect, 4000);
    //     }
    //   }

    //   function wsdisconnect() {
    //     if (socket) {
    //       //log('Disconnecting...')
    //       socket.close()
    //       socket = null

    //       updateConnectionStatus()
    //     }
    //   }

      function updateConnectionStatus() {
        if (socket) {
        //   $status.style.backgroundColor = 'transparent'
        //   $status.style.color = 'green'
        //   $status.textContent = `connected`
        //   $connectButton.innerHTML = 'Disconnect'
          //$input.focus()
          get_sessions();
        } else {
        //   $status.style.backgroundColor = 'red'
        //   $status.style.color = 'white'
        //   $status.textContent = 'disconnected'
        //   $connectButton.textContent = 'Connect'
        }
      }

    // document.addEventListener("visibilitychange", () => {
    //     console.log(document.hidden);
    //     try_ws_reconnect();
    //     // Modify behavior…
    // });

    //   $connectButton.addEventListener('click', () => {
    //     if (socket) {
    //       wsdisconnect()
    //     } else {
    //         wsconnect()
    //     }

    //     updateConnectionStatus()
    //   })

    //   $form.addEventListener('submit', (ev) => {
    //     ev.preventDefault()

    //     const text = $input.value

    //     //log('Sending: ' + text)
    //     socket.send(text)

    //     $input.value = ''
    //     $input.focus()
    //   })

      updateConnectionStatus();
    </script>
</body>
</html>
