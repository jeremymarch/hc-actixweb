<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta charset="UTF-8">
    <title>Hoplite Challenge</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<script nonce="2726c7f26c" type="text/javascript">
    'use strict';
    function q (i) { return document.querySelector(i); }
    function setTheme () {
      const mode = localStorage.getItem('mode');
      if ((window.matchMedia('(prefers-color-scheme: dark)').matches || mode === 'dark') && mode !== 'light') {
        q('HTML').classList.add('dark');
      } else {
        q('HTML').classList.remove('dark');
      }
    }
    setTheme();
</script>
<style nonce="2726c7f26c">
@font-face {
    font-family: 'WebNewAthenaUnicode';
    src: url('/newathu5_8.ttf') format('truetype');
}
* { box-sizing: border-box; }
BODY { font-family:helvetica neue,helvetica, arial, sans-serif;margin:0px; }
.gkinput, .gkinputnontyping {
    font-family: WebNewAthenaUnicode,NewAthenaUnicode, helvetica,arial;
}
#loginContainer {
  padding:0px 20px;
}
#appTitle {
  font-weight:bold;
}
#newGameRow {
  margin-bottom: 0px;
}
#maxtime {
  width:30px;
}
#correctanswer {
  visibility: hidden;
}
#mainTime { font-size:1rem;}
#loginlink { display: inline; }
#logoutlink { display: none; }
.loggedin #loginlink { display: none; }
.loggedin #logoutlink { display: inline; }
.sym {
    font-family: "AppleColorEmoji","Apple Color Emoji","Segoe UI Emoji",'Noto Color Emoji',"NotoColorEmoji","Segoe UI Symbol","EmojiSymbols",Symbola,"Android Emoji","AndroidEmoji","Arial Unicode MS","Zapf Dingbats","AppleSDGothicNeo-Regular","lucida grande",tahoma,verdana,arial,sans-serif;
    text-rendering: optimizeLegibility;
}
.gkinput, .gkinputcodes, .gkinputnontyping {
    -webkit-box-sizing: border-box; /* Safari/Chrome, other WebKit */
    -moz-box-sizing: border-box;    /* Firefox, other Gecko */
    box-sizing: border-box;         /* Opera/IE 8+ */
    width: 100%;
    padding: 0px 0.5em;
    height: 40px;
    font-size: 20pt;
    margin:6px 0px;
    resize: none;
}
/*.gkinput:focus, .gkinputcodes:focus, .gkinputnontyping:focus{
    outline:2px solid #6677dd;
}*/

.verbunitrowlabel {
  color: blue;
  cursor: pointer;
}
.dark .verbunitrowlabel {
  color: #03A5F3;
}

.startingform {
    width:100%;
    display:flex;
    justify-content: center;
    align-items: center;
    margin:1rem auto;
    height:6rem;
    font-size:2rem;
    border:1px solid black;
    text-align: center;
    border-radius:0.5rem;
    font-family: WebNewAthenaUnicode,NewAthenaUnicode, helvetica,arial;
}
.newform {
    width:100%;
    display:block;
    margin:1px auto;
    height:6rem;
    font-size:2rem;
    border:1px solid black;
    text-align: center;
    padding:1rem;
    border-radius:0.5rem;
    font-family: WebNewAthenaUnicode,NewAthenaUnicode, helvetica,arial;
}
.changedesc {
    width:100%;
    display:block;
    margin:1.5rem auto;
    height:2rem;
    font-size:1.5rem;
    text-align: center;
}
#statusmesg {
    display: block;
    margin: 0rem auto;
    font-size: 1rem;
    text-align: center;
    border-top: 1px solid black;
    padding-top: 0.5rem;
}
.correctanswer {
    width:100%;
    display:block;
    margin:1rem auto;
    font-size:2rem;
    text-align: center;
    height:2rem;
}
#submitbutton {
    margin:1rem auto;
    width:6rem;
    height:2rem;
}
BUTTON {border-radius: 0.5rem;cursor: pointer;}
BUTTON:disabled {cursor:default}

#mainstopwatch {
    float:right;
}
.hbox {
    width:100%;
    margin:10px auto;
    height:30px;
    margin-top: 0px;
}
#askparamsdiv {
    width:100%;
    margin:0px auto;
}
#askparamsdivinner SELECT { display:block;}
#askparamsdivinner {
    width:100%;
    margin:0px auto;
    justify-content: center;
    display:flex;
}
.mfbutton {
    float: left;
    width: 6rem;
    height: 2rem;
}
.addheight{
    top:28px;
}
#listouter {
    border:2px solid black;
    border-top:0px solid black;
    width:320px;
    position: absolute;
    top: 1.5rem;
    left: 1rem;
    transition: top 2s;
    z-index:899;
}

/* #list { } */

#creategamebutton {
    display: block;
    margin: 0px auto;
    margin-top:1rem;
    text-align:center;
}
#menubar {
    height:1.5rem;
    border-bottom:1px solid black;
    display:flex;
    justify-content: flex-end;
    background-color:white;
    position:relative;
    z-index:900;
    padding:0.2rem 1rem;
}
/* .myturn {
   
} */
.selectedGame {
    background-color: lightgray;
}
.myturnIcon {
    fill: red;
    width: 1rem;
    top: 0.4rem;
    position: absolute;
    right:0rem;
}
#askparamsdiv {
    display: none;
}
.hcform {
    display: none;
    border: 2px solid gray;
    width: 40rem;
    margin: 1rem auto;
    padding: 1rem;
    border-radius: 1rem;
    padding-bottom: 0.5rem;
    background-color: lightgrey;
    z-index: 999;
    position: relative;
}
.icon {
    height: 26px;
    width: 26px;
}
#verbchooser {
    display: none;
}
.gamerow {
    position: relative;
    padding: 0.25rem;
    margin: 0.5rem;
    cursor:pointer;
}
.gamespan {
    color:blue;
}
.paramdiv {
    margin: 10px 4px;
    border-bottom: 4px solid white;
    padding-bottom: 4px;
}
.paramdivchanged {
    border-bottom: 4px solid red;
}

a {color:blue;}

#verblist {
    font-family: WebNewAthenaUnicode,NewAthenaUnicode, helvetica,arial;
    margin-top: 6px;
}

.limitparam, .verblistck {
  margin-right: 0.5rem;
}
.limitparamrow {
  line-height: 1.5;
}

.myturnIcon { display:none; }
.myturn .myturnIcon { display:block; }

.startingform {border: 1px solid black;background-color:white}
#answerform {border: 1px solid black;background-color:white}

#changedesc b { border-bottom:0.2rem solid red; padding-bottom:0.1rem;}

.dark BODY { background-color: black;color:white; }
.dark .hcform { background-color: #202124;color:white; }
.dark .startingform {border: 1px solid white;background-color:black}
.dark #statusmesg {border-top: 1px solid white;}
.dark #listouter {border: 1px solid white;border-top:0px solid white;}
.dark #settings .expand-container {/*border: 2px solid white;*/background-color: black;}
.dark #menubar { background-color: black;color:white;border-bottom: 1px solid white; }
.dark #answerform {background-color: black;color:white;border: 1px solid white;}
.dark #mfbutton {background-color: black;color:white;border: 1px solid white;}
.dark #mfbutton:disabled {background-color: black;color:#666;border: 1px solid white;}
.dark #submitbutton {background-color: black;color:white;border: 1px solid white;}
.dark .paramdiv {border-bottom: 4px solid transparent;}
.dark .paramdivchanged { border-bottom: 4px solid red;}
.dark a {color:#03A5F3;}
.dark .gamespan { color:#03A5F3; }
.dark .gamerow.selectedGame {background-color: white;}

.dark .gamerow {background-color:#202124;}

#container {
   border: 1px solid black;
   padding: 15px;
}

.expand-container {
  overflow: hidden;
}

#newgamediv {
    margin-left: 1rem;
    margin-right: 1rem;
    margin-bottom: 1rem;
}
.expand-contract {
  margin-top: -345px;
  transition: all 0.3s ease-in-out;
}

#customparams .expand-contract {
  margin-top: -435px;
}

.expand-contract.expanded {
   margin-top: 0 !important;
   transition: all 0.3s ease-in-out;
}
.verbrow {
    margin-left:1.5rem;
}
.verbunitrow { font-family: Helvetica, Arial, sans-serif;line-height: 1.5;}
#verbscontainer { margin-top:-482px; }
#closebutton {    float: left;
    width: 2rem;
    height: 2rem;display:none;
}

.newrow { display:flex;flex-direction: row;padding: 4px 0px;}
.newcol1 {width:125px;}
.newgameinput { width:155px;}

@media only screen and (max-width: 800px) {
  .hcform {
    width:100%;
  }
  #listouter {
    width: 100%;
    left: 0rem;
    border:0px solid black;
  }
  .dark #listouter {
    border:0px solid black;
  }
  #closebutton {
    display:inline-block;
  }
  .gamerow {
    line-height: 2;
    height:44px;
  }
}
</style>
</head>
<body>
    <div id="menubar">
        <div id="loginContainer"><a id="loginlink" href="login">login</a>
            <span id="logoutlink">
              <span id="username"></span> 
              (<a href="logout">logout</a>)
            </span>
        </div>
        <div id="appTitle">HOPLITE CHALLENGE</div>
    </div>
    <div id="listouter">
        <div id="settings">
            <div id="newGameRow" class="gamerow">
              <span class="gamespan">New</span>
            </div>
            <div class="expand-container">
                <div id="newgamediv" class="expand-contract">
                    <div class="table">
                        <div class="newrow"><div class="newcol1">Type</div>
                        <div class="newcol2">
                          practice <input checked name="gametype" id="gametypepractice" type="radio" value="practice"/> 
                          game <input name="gametype" id="gametypegame" type="radio" value="game"/>
                        </div></div>
                        <div class="expand-container">
                            <div id="opponentrow" class="newrow expand-contract">
                              <div class="newcol1">Opponent:</div>
                              <div class="newcol2"><input id="opponentinput" type="text" class="newgameinput"/></div>
                            </div>
                        </div>
                        <div class="newrow">
                          <div class="newcol1">Timer:</div>
                          <div class="newcol2">
                            <input name="countdown" id="countdowninput" type="radio" value="down"/>countdown 
                            <input id="maxtime" type="text" value="30"/><br/>
                            <input checked name="countdown" id="countupinput" type="radio" value="up"/>elapsed 
                          </div>
                        </div>
                        <div class="newrow">
                          <div class="newcol1">Reps per verb:</div>
                          <div class="newcol2">
                            <input id="repsperverb" type="text" value="4" class="newgameinput"/>
                          </div>
                        </div>
                        <div class="newrow">
                          <div class="newcol1">Max changes:</div>
                          <div class="newcol2"><input id="maxchanges" type="text" value="2" class="newgameinput"/></div>
                        </div>
                        <div class="newrow">
                          <div class="newcol1">Forms from Unit and below:</div>
                          <div class="newcol2">
                            <input id="topunit" type="text" value="" class="newgameinput"/>
                          </div>
                        </div>
                    </div>
                    <div id="verblist"></div>
                    <div id="customparams">
                      <div><span class="verbunitrowlabel">Customize Parameters</span></div><div class="expand-container"><div class="expand-contract">
                          <div class="limitparamrow"><input class="limitparam" value="1" id="paramfirst" type="checkbox">First Person</div>
                          <div class="limitparamrow"><input class="limitparam" value="2" id="paramsecond" type="checkbox">Second Person</div>
                          <div class="limitparamrow"><input class="limitparam" value="3" id="paramthird" type="checkbox">Third Person</div>
                          <div class="limitparamrow"><input class="limitparam" value="4" id="paramsing" type="checkbox">Singular</div>
                          <div class="limitparamrow"><input class="limitparam" value="5" id="paramplural" type="checkbox">Plural</div>
                          <div class="limitparamrow"><input class="limitparam" value="6" id="parampresent" type="checkbox">Present</div>
                          <div class="limitparamrow"><input class="limitparam" value="7" id="paramimperfect" type="checkbox">Imperfect</div>
                          <div class="limitparamrow"><input class="limitparam" value="8" id="paramfuture" type="checkbox">Future</div>
                          <div class="limitparamrow"><input class="limitparam" value="9" id="paramaorist" type="checkbox">Aorist</div>
                          <div class="limitparamrow"><input class="limitparam" value="10" id="paramperfect" type="checkbox">Perfect</div>
                          <div class="limitparamrow"><input class="limitparam" value="11" id="paramplup" type="checkbox">Pluperfect</div>
                          <div class="limitparamrow"><input class="limitparam" value="12" id="paramindic" type="checkbox">Indicative</div>
                          <div class="limitparamrow"><input class="limitparam" value="13" id="paramsubj" type="checkbox">Subjunctive</div>
                          <div class="limitparamrow"><input class="limitparam" value="14" id="paramindic" type="checkbox">Optative</div>
                          <div class="limitparamrow"><input class="limitparam" value="15" id="paramsubj" type="checkbox">Imperative</div>
                          <div class="limitparamrow"><input class="limitparam" value="16" id="paramact" type="checkbox">Active</div>
                          <div class="limitparamrow"><input class="limitparam" value="17" id="parammid" type="checkbox">Middle</div>
                          <div class="limitparamrow"><input class="limitparam" value="18" id="parampass" type="checkbox">Passive</div>
                        </div>
                      </div>
                    </div>
                    <div><button id="creategamebutton">Create Game</button></div>
                </div>
            </div>
        </div>
        <div id="list"></div>
    </div>

    <div class="hcform">
    <div class="hbox">
        <button id="closebutton" class="closebutton" title="Close form">X</button>
        <button id="mfbutton" class="mfbutton" title="Multiple Forms Button">MF</button>
        <div id="mainstopwatch">
            <div id="mainTime">
                
            </div>
        </div>
    </div>
<div id="startingformouter" class="startingform">
    <div id="startingform" class=""></div>
    <select id="verbchooser">
    </select>
</div>

<div id="changedesc" class="changedesc"></div>

<div id="askparamsdiv">
    <div id="askparamsdivinner">
        <div id="personparamdiv" class="paramdiv">
            <select id="personparam">
                <option value="0">First</option>
                <option value="1">Second</option>
                <option value="2">Third</option>
            </select>
        </div>
        <div id="numberparamdiv" class="paramdiv">
            <select id="numberparam">
                <option value="0">Singular</option>
                <option value="1">Plural</option>
            </select>
        </div>
        <div id="tenseparamdiv" class="paramdiv">
            <select id="tenseparam">
                <option value="0">Present</option>
                <option value="1">Imperfect</option>
                <option value="2">Future</option>
                <option value="3">Aorist</option>
                <option value="4">Perfect</option>
                <option value="5">Pluperfect</option>
            </select>
        </div>
        <div id="moodparamdiv" class="paramdiv">
            <select id="moodparam">
                <option value="0">Indicative</option>
                <option value="1">Subjunctive</option>
                <option value="2">Optative</option>
                <option value="3">Imperative</option>
            </select>
        </div>
        <div id="voiceparamdiv" class="paramdiv">
            <select id="voiceparam">
                <option value="0">Active</option>
                <option value="1">Middle</option>
                <option value="2">Passive</option>
            </select>
        </div>
    </div>
</div>
<textarea id="answerform" class="gkinput newform disablecopypaste" 
  disabled autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"></textarea>
<div id="correctanswer" class="gkinput correctanswer"></div>
<button id="submitbutton">Start</button>
<div id="statusmesg">press start to begin</div>
</div>
<script nonce="2726c7f26c" type="module">
  // eslint-disable-next-line import/no-named-default
  import { toggle, translit, default as init } from './hoplitekb_wasm_rs.js';

  async function run () {
    await init('./hoplitekb_wasm_rs_bg.wasm');
    // make the function available to the browser
    window.toggle = toggle;
    window.translit = translit;
  }
  run();
</script>
<script nonce="2726c7f26c" type="text/javascript">
  'use strict';

  function typeChanged () {
    if (this.value === 'game') {
      document.querySelector('#opponentrow').classList.add('expanded');
    } else {
      document.querySelector('#opponentrow').classList.remove('expanded');
      document.querySelector('#opponentinput').value = '';
    }
  }

  let timeout = null;
  (function (global, factory) {
    // eslint-disable-next-line no-undef
    if (typeof define === 'function' && define.amd) {
      // eslint-disable-next-line no-undef
      define([], factory);
    } else if (typeof module !== 'undefined' && module.exports) {
      module.exports = factory();
    } else {
      global.ReconnectingWebSocket = factory();
    }
  })(this, function () {
    if (!('WebSocket' in window)) {
      return;
    }
  
    function ReconnectingWebSocket (url, protocols, options) {
      // Default settings
      const settings = {

        /** Whether this instance should log debug messages. */
        debug: false,

        /** Whether or not the websocket should attempt to connect immediately upon instantiation. */
        automaticOpen: true,

        /** The number of milliseconds to delay before attempting to reconnect. */
        reconnectInterval: 1000,
        /** The maximum number of milliseconds to delay a reconnection attempt. */
        maxReconnectInterval: 30000,
        /** The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. */
        reconnectDecay: 1.5,

        /** The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. */
        timeoutInterval: 2000,

        /** The maximum number of reconnection attempts to make. Unlimited if null. */
        maxReconnectAttempts: null,

        /** The binary type, possible values 'blob' or 'arraybuffer', default 'blob'. */
        binaryType: 'blob'
      };
      if (!options) { options = {}; }

      // Overwrite and define settings with options if they exist.
      for (const key in settings) {
        if (typeof options[key] !== 'undefined') {
          this[key] = options[key];
        } else {
          this[key] = settings[key];
        }
      }

      // These should be treated as read-only properties

      /** The URL as resolved by the constructor. This is always an absolute URL. Read only. */
      this.url = url;

      /** The number of attempted reconnects since starting, or the last successful connection. Read only. */
      this.reconnectAttempts = 0;

      /**
       * The current state of the connection.
       * Can be one of: WebSocket.CONNECTING, WebSocket.OPEN, WebSocket.CLOSING, WebSocket.CLOSED
       * Read only.
       */
      this.readyState = WebSocket.CONNECTING;

      /**
       * A string indicating the name of the sub-protocol the server selected; this will be one of
       * the strings specified in the protocols parameter when creating the WebSocket object.
       * Read only.
       */
      this.protocol = null;

      // Private state variables

      const self = this;
      let ws;
      let forcedClose = false;
      let timedOut = false;
      const eventTarget = document.createElement('div');

      // Wire up "on*" properties as event handlers

      eventTarget.addEventListener('open', function (event) { self.onopen(event); });
      eventTarget.addEventListener('close', function (event) { self.onclose(event); });
      eventTarget.addEventListener('connecting', function (event) { self.onconnecting(event); });
      eventTarget.addEventListener('message', function (event) { self.onmessage(event); });
      eventTarget.addEventListener('error', function (event) { self.onerror(event); });

      // Expose the API required by EventTarget

      this.addEventListener = eventTarget.addEventListener.bind(eventTarget);
      this.removeEventListener = eventTarget.removeEventListener.bind(eventTarget);
      this.dispatchEvent = eventTarget.dispatchEvent.bind(eventTarget);

      /**
     * This function generates an event that is compatible with standard
     * compliant browsers and IE9 - IE11
     *
     * This will prevent the error:
     * Object doesn't support this action
     *
     * http://stackoverflow.com/questions/19345392/why-arent-my-parameters-getting-passed-through-to-a-dispatched-event/19345563#19345563
     * @param s String The name that the event should use
     * @param args Object an optional object that the event will use
     */
      function generateEvent (s, args) {
        const evt = document.createEvent('CustomEvent');
        evt.initCustomEvent(s, false, false, args);
        return evt;
      };

      this.open = function (reconnectAttempt) {
        ws = new WebSocket(self.url, protocols || []);
        ws.binaryType = this.binaryType;

        if (reconnectAttempt) {
          if (this.maxReconnectAttempts && this.reconnectAttempts > this.maxReconnectAttempts) {
            return;
          }
        } else {
          eventTarget.dispatchEvent(generateEvent('connecting'));
          this.reconnectAttempts = 0;
        }

        if (self.debug || ReconnectingWebSocket.debugAll) {
          console.debug('ReconnectingWebSocket', 'attempt-connect', self.url);
        }

        const localWs = ws;
        timeout = setTimeout(function () {
          if (self.debug || ReconnectingWebSocket.debugAll) {
            console.debug('ReconnectingWebSocket', 'connection-timeout', self.url);
          }
          timedOut = true;
          localWs.close();
          timedOut = false;
        }, self.timeoutInterval);

        ws.onopen = function (event) {
          clearTimeout(timeout);
          if (self.debug || ReconnectingWebSocket.debugAll) {
            console.debug('ReconnectingWebSocket', 'onopen', self.url);
          }
          self.protocol = ws.protocol;
          self.readyState = WebSocket.OPEN;
          self.reconnectAttempts = 0;
          const e = generateEvent('open');
          e.isReconnect = reconnectAttempt;
          reconnectAttempt = false;
          eventTarget.dispatchEvent(e);
        };

        ws.onclose = function (event) {
          clearTimeout(timeout);
          ws = null;
          if (forcedClose) {
            self.readyState = WebSocket.CLOSED;
            eventTarget.dispatchEvent(generateEvent('close'));
          } else {
            self.readyState = WebSocket.CONNECTING;
            const e = generateEvent('connecting');
            e.code = event.code;
            e.reason = event.reason;
            e.wasClean = event.wasClean;
            eventTarget.dispatchEvent(e);
            if (!reconnectAttempt && !timedOut) {
              if (self.debug || ReconnectingWebSocket.debugAll) {
                console.debug('ReconnectingWebSocket', 'onclose', self.url);
              }
              eventTarget.dispatchEvent(generateEvent('close'));
            }

            timeout = self.reconnectInterval * Math.pow(self.reconnectDecay, self.reconnectAttempts);
            setTimeout(function () {
              self.reconnectAttempts++;
              self.open(true);
            }, timeout > self.maxReconnectInterval ? self.maxReconnectInterval : timeout);
          }
        };
        ws.onmessage = function (event) {
          if (self.debug || ReconnectingWebSocket.debugAll) {
            console.debug('ReconnectingWebSocket', 'onmessage', self.url, event.data);
          }
          const e = generateEvent('message');
          e.data = event.data;
          eventTarget.dispatchEvent(e);
        };
        ws.onerror = function (event) {
          if (self.debug || ReconnectingWebSocket.debugAll) {
            console.debug('ReconnectingWebSocket', 'onerror', self.url, event);
          }
          eventTarget.dispatchEvent(generateEvent('error'));
        };
      };

      // Whether or not to create a websocket upon instantiation
      if (this.automaticOpen === true) {
        this.open(false);
      }

      /**
         * Transmits data to the server over the WebSocket connection.
         *
         * @param data a text string, ArrayBuffer or Blob to send to the server.
         */
      this.send = function (data) {
        if (ws) {
          if (self.debug || ReconnectingWebSocket.debugAll) {
            console.debug('ReconnectingWebSocket', 'send', self.url, data);
          }
          return ws.send(data);
        } else {
          // throw 'INVALID_STATE_ERR : Pausing to reconnect websocket';
          throw Object.assign(
            new Error('INVALID_STATE_ERR : Pausing to reconnect websocket'),
            { code: 402 }
          );
        }
      };

      /**
     * Closes the WebSocket connection or connection attempt, if any.
     * If the connection is already CLOSED, this method does nothing.
     */
      this.close = function (code, reason) {
        // Default CLOSE_NORMAL code
        if (typeof code === 'undefined') {
          code = 1000;
        }
        forcedClose = true;
        if (ws) {
          ws.close(code, reason);
        }
      };

      /**
     * Additional public API method to refresh the connection if still open (close, re-open).
     * For example, if the app suspects bad data / missed heart beats, it can try to refresh.
     */
      this.refresh = function () {
        if (ws) {
          ws.close();
        }
      };
    }

    /**
       * An event listener to be called when the WebSocket connection's readyState changes to OPEN;
       * this indicates that the connection is ready to send and receive data.
       */
    ReconnectingWebSocket.prototype.onopen = function (event) {};
    /** An event listener to be called when the WebSocket connection's readyState changes to CLOSED. */
    ReconnectingWebSocket.prototype.onclose = function (event) {};
    /** An event listener to be called when a connection begins being attempted. */
    ReconnectingWebSocket.prototype.onconnecting = function (event) {};
    /** An event listener to be called when a message is received from the server. */
    ReconnectingWebSocket.prototype.onmessage = function (event) {};
    /** An event listener to be called when an error occurs. */
    ReconnectingWebSocket.prototype.onerror = function (event) {};

    /**
   * Whether all instances of ReconnectingWebSocket should log debug messages.
   * Setting this to true is the equivalent of setting all instances of ReconnectingWebSocket.debug to true.
   */
    ReconnectingWebSocket.debugAll = false;

    ReconnectingWebSocket.CONNECTING = WebSocket.CONNECTING;
    ReconnectingWebSocket.OPEN = WebSocket.OPEN;
    ReconnectingWebSocket.CLOSING = WebSocket.CLOSING;
    ReconnectingWebSocket.CLOSED = WebSocket.CLOSED;

    return ReconnectingWebSocket;
  });

  /* global q */
  let globalCountDown = false;
  let globalUserName = null;
  let globalTimerIntV = null;
  let globalCountDownDate = null;
  let globalStartingForm = null;
  let globalChangeDesc = null;
  let globalMaxChanges = null;
  const globalShowCorrect = false;
  let globalSessionState = null;
  let globalSessionId = null;
  let globalMFPressed = false;
  let globalTimedOut = false;
  let globalSeconds = 30;
  let globalTimerRef = null;
  const unicodeMode = 0;
  const myturnIcon = '<svg class="myturnIcon" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><circle cx="50" cy="50" r="50" /></svg>';
  const correctIcon = '<svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" enable-background="new 0 0 64 64"><path d="M32,2C15.431,2,2,15.432,2,32c0,16.568,13.432,30,30,30c16.568,0,30-13.432,30-30C62,15.432,48.568,2,32,2z M25.025,50  l-0.02-0.02L24.988,50L11,35.6l7.029-7.164l6.977,7.184l21-21.619L53,21.199L25.025,50z" fill="#43a047"/></svg>';
  const incorrectIcon = '<svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" enable-background="new 0 0 64 64"><path d="m32 2c-16.568 0-30 13.432-30 30s13.432 30 30 30 30-13.432 30-30-13.432-30-30-30m5.513 44.508l-5.514-9.894-5.825 9.894h-7.048l9.331-14.783-8.878-14.232h7.244l5.175 9.449 5.317-9.449h7.008l-8.878 13.996 9.429 15.02h-7.361z" fill="#e53935"/></svg>';
  // Check for wasm support.
  if (!('WebAssembly' in window)) {
    alert('you need a browser with wasm support enabled :(');
  }

  window.addEventListener('load', start, false);
  document.getElementById('closebutton').addEventListener('click', closeClicked, false);
  document.getElementById('mfbutton').addEventListener('click', mfClicked, false);
  document.getElementById('submitbutton').addEventListener('click', submitClicked, false);
  document.getElementById('creategamebutton').addEventListener('click', newGameClicked, false);
  document.getElementById('newGameRow').addEventListener('click', expandContractNewGameDiv, false);

  document.getElementById('gametypepractice').addEventListener('change', typeChanged, false);
  document.getElementById('gametypegame').addEventListener('change', typeChanged, false);
  
  const paramItems = document.querySelectorAll('#askparamsdivinner SELECT');
  for (let i = 0; i < paramItems.length; i++) {
    paramItems[i].addEventListener('change', selectChanged, false);
  }

  function selectChanged () {
    const changedNodes = document.querySelectorAll('.paramdivchanged');
    if (changedNodes && globalMaxChanges !== null && changedNodes.length >= globalMaxChanges &&
      this.value !== this.getAttribute('orig') &&
        !this.parentNode.classList.contains('paramdivchanged')) {
      this.value = this.getAttribute('orig');
    }
    if (this.value !== this.getAttribute('orig') && globalMaxChanges !== null) {
      this.parentNode.classList.add('paramdivchanged');
    } else {
      this.parentNode.classList.remove('paramdivchanged');
    }
  }

  // function strToCodePoints (str) {
  //   let a = '';
  //   for (let i = 0; i < str.length; i++) {
  //     a += str.codePointAt(i).toString(16).padStart(4, '0').toUpperCase() + ' ';
  //   }
  //   return a.trim();
  // }

  const supportsWebSockets = false; // 'WebSocket' in window || 'MozWebSocket' in window;
  function start () {
    verbList();
    globalTimerRef = q('#mainTime');
  
    const supported = (() => {
      try {
        if (typeof WebAssembly === 'object' &&
                typeof WebAssembly.instantiate === 'function') {
          const module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));
          if (module instanceof WebAssembly.Module) {
            return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;
          }
        }
      } catch (e) { console.log('error checking for webassembly: ' + e.message); }
      return false;
    })();
    if (!supported) {
      console.log('WebAssembly is not supported');
    }

    // block pasting
    const answerform = q('#answerform');
    answerform.addEventListener('paste', (event) => {
      event.preventDefault();
    });

    answerform.addEventListener('keypress', handleKey, false);

    // is it safe to store session id here on a shared computer with multiple users?
    // globalSessionId = localStorage.getItem('selected_session_id');
    if (supportsWebSockets) {
      wsconnect();
    } else {
      getSessions(true);
    }
    console.log(getTextWidth('παιδεύσητε', 'normal 24pt WebNewAthenaUnicode')); // close to 86
  }

  function getTextWidth (text, font) {
    // re-use canvas object for better performance
    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement('canvas'));
    const context = canvas.getContext('2d');
    context.font = font;
    const metrics = context.measureText(text);
    return metrics.width;
  }

  // function getCssStyle(element, prop) {
  //     return window.getComputedStyle(element, null).getPropertyValue(prop);
  // }

  // function getCanvasFont(el = document.body) {
  //   const fontWeight = getCssStyle(el, 'font-weight') || 'normal';
  //   const fontSize = getCssStyle(el, 'font-size') || '16px';
  //   const fontFamily = getCssStyle(el, 'font-family') || 'Times New Roman';

  //   return `${fontWeight} ${fontSize} ${fontFamily}`;
  // }

  function toggleDiacritic (str, pos, diacritic, unicodeMode) {
    if (pos < 0 || pos > str.length) {
      return { str, pos: str.length };
    }
    const maxCombiningChars = 10;
    const replaceLen = Math.min(maxCombiningChars + 1, pos);
    const s = str.slice(pos - replaceLen, pos);
    // eslint-disable-next-line no-undef
    const res = toggle(s, parseInt(diacritic), false, parseInt(unicodeMode));

    const newPos = (pos - replaceLen) + res.length;

    return { str: str.slice(0, pos - replaceLen) + res + str.slice(pos), pos: newPos };
  }

  function handleKey (e) {
    if (typeof (this.selectionStart) === 'number' && typeof (this.selectionEnd) === 'number') {
      const text = this.value;
      const start = this.selectionStart;
      const key = e.key.toLowerCase(); // force lower case

      if (key === 'enter') { // enter key
        submitClicked();
        return false;
      } else if (!isNaN(parseInt(key))) {
        const res = toggleDiacritic(text, start, key, unicodeMode);
        this.value = res.str;
        this.selectionStart = this.selectionEnd = res.pos;
        e.preventDefault();
        return false;
      } else if (key.length === 1) { // len == 1 to exclude keys like "ENTER", etc.
        // eslint-disable-next-line no-undef
        const greekLetter = translit(key); // returns \0 if the character cannot be transliterated
        if (greekLetter !== '\0') {
          const end = this.selectionEnd;
          this.value = text.slice(0, start) + greekLetter + text.slice(end);
          this.selectionStart = this.selectionEnd = start + 1;
          e.preventDefault();
          return false;
        }
      }
    }
    return true; // true allows most punctuation, etc. pass through
  }
  
  // https://github.com/le717/microajax
  function microAjax (options) {
    'use strict';

    // Default to GET
    if (!options.method) {
      options.method = 'GET';
    }

    // Default empty functions for the callbacks
    function noop () {}
    if (!options.success) {
      options.success = noop;
    }
    if (!options.warning) {
      options.warning = noop;
    }
    if (!options.error) {
      options.error = noop;
    }

    const request = new XMLHttpRequest();
    request.open(options.method, options.url, true);
    // request.setRequestHeader('Content-type', 'application/json; charset=UTF-8')
    request.setRequestHeader('Content-type', 'application/x-www-form-urlencoded; charset=UTF-8');
    request.send(options.data);

    request.onload = function () {
      // Success!
      if (request.readyState === 4 && request.status === 200) {
        options.success(JSON.parse(request.responseText));

        // We reached our target destination, but it returned an error
      } else {
        options.warning(request.responseText);
      }
    };

    // There was a connection error of some sort
    request.onerror = options.error;
  }

  function procResponseError (data) {
    console.log(data);
  }

  function procResponse (data) {
    console.log(data);

    // if (handleResponse !== null) {
    //     handleResponse(data);
    // }
    // else
    if (data.response_to === 'ask' && data.success) {
      getSessions(false);
      uiModeAskResponse(data);
    } else if ((data.response_to === 'answerresponse' || data.response_to === 'answerresponsepractice') && data.success) {
      getSessions(false);

      globalStartingForm = data.starting_form;
      globalChangeDesc = data.change_desc;
      uiModeAnswerResponseReceived(data);
    } else if ((data.response_to === 'mfpressedresponse' || data.response_to === 'mfpressedresponsepractice') && data.success) {
      if (data.is_correct === false) {
        uiModeClickedEnter();
  
        globalStartingForm = data.starting_form;
        globalChangeDesc = data.change_desc;
        uiModeAnswerResponseReceived(data);
      }
    } else if (data.response_to === 'newsession' && data.success) {
      getSessions(true);
    } else if (data.response_to === 'getmoves' && data.success) {
      if (data.myturn && data.move_type !== 'Practice') {
        q(".gamerow[data-uuid='" + data.session_id + "']").classList.add('myturn');
      } else {
        q(".gamerow[data-uuid='" + data.session_id + "']").classList.remove('myturn');
      }
      setUI(data);
    } else if (data.response_to === 'getsessions' && data.success) {
      if (data.username) {
        document.body.classList.add('loggedin');
        q('#username').innerText = data.username;
        globalUserName = data.username;
      } else {
        document.body.classList.remove('loggedin');
        q('#username').innerText = '';
        globalUserName = null;
      }

      let rows = '';
      for (let i = 0; i < data.sessions.length; i++) {
        const s = data.sessions[i];
        if (s.move_type !== 'FirstMoveTheirTurn') { // do not show if first move not asked yet and I did not start game
          rows += "<div data-uuid='" + s.session_id + "' ";
          rows += "data-max-changes='" + s.max_changes + "' ";
          rows += "data-max-time='" + s.max_time + "' ";
          rows += "data-countdown='" + (s.countdown !== 0) + "' ";
          rows += "class='gamerow" + (s.myturn && s.move_type !== 'Practice' ? ' myturn' : '');
          rows += (s.session_id === globalSessionId ? ' selectedGame' : '') + "' ";
          rows += (s.opponent_name ? "opponent='" + s.opponent_name + "' " : '');
          rows += "title='" + s.move_type + "'><span class='gamespan'>";
          rows += (s.move_type === 'Practice' ? 'Practice' : (globalUserName || 'Game'));
          rows += (s.opponent_name ? ' vs. ' + s.opponent_name : '');
          rows += (s.move_type !== 'Practice' ? (' (' + s.my_score + ' - ' + s.their_score + ')') : '');
          rows += myturnIcon + '</span></div>';
        }
        // q(".gamerow[data-uuid='b72df91e-3a4c-4f1b-aeda-c14fea61def6']").style.backgroundColor = "blue";
      }
      q('#list').innerHTML = rows;

      // fix me need to exclude New row from here
      const rowItems = document.querySelectorAll('.gamerow');
      for (let i = 0; i < rowItems.length; i++) {
        if (rowItems[i].id !== 'newGameRow') {
          rowItems[i].addEventListener('click', getMove, false);
        }
      }

      // q("#refreshbutton").style.display = "block";
      // q("#listouter").style.display = "block";

      if (data.current_session) {
        setUI(data.current_session);
      }
    }
  }

  function serialize (obj) {
    const str = [];
    for (const p in obj) {
      if (Object.hasOwn(obj, p)) {
        str.push(encodeURIComponent(p) + '=' + encodeURIComponent(obj[p]));
      }
    }
    return str.join('&');
  }

  const fallbackToAjax = true;
  // const pendingSendData = null;
  function genericSendRequest (sendUrl, sendData, handleResponse) {
    // if (supportsWebSockets && !socket) {
    //     wsconnect(sendUrl, sendData);
    //     return;
    // }

    if (supportsWebSockets && socket) {
      console.log('websocket request');
      sendData = JSON.stringify(sendData);
      socket.send(sendData);
    } else {
      console.log("ws not connected: can't send.");
      /*
        pendingSendData = sendData;
        wsconnect();
        */

      if (fallbackToAjax) {
        console.log('http request');
        sendData = serialize(sendData);
        microAjax({
          url: sendUrl,
          method: 'POST',
          data: sendData,
          success: procResponse,
          warning: procResponseError,
          error: null
        });
      }
    }
  }

  function sendAsk (sessionId, person, number, tense, mood, voice, verbId) {
    const sendData = { qtype: 'ask', session_id: sessionId, person: parseInt(person), number: parseInt(number), tense: parseInt(tense), mood: parseInt(mood), voice: parseInt(voice), verb: parseInt(verbId) };
    genericSendRequest('ask', sendData, null);
  }

  function sendAnswer (sessionId, answer, time, mfPressed, timedOut) {
    const sendData = { qtype: 'submit', answer, time, mf_pressed: mfPressed, timed_out: timedOut, session_id: sessionId };
    genericSendRequest('enter', sendData, null);
  }

  function sendMF (sessionId, answer, time, mfPressed, timedOut) {
    const sendData = { qtype: 'mfpressed', answer, time, mf_pressed: mfPressed, timed_out: timedOut, session_id: sessionId };
    genericSendRequest('mf', sendData, null);
  }

  function newGameClicked () {
    // let unitv = q("#unitinput").value.trim();
    const opponentv = q('#opponentinput').value.trim();
    const countdown = (q('input[name=countdown]:checked').value === 'down');
    let reps = parseInt(q('#repsperverb').value.trim());
    let maxChanges = parseInt(q('#maxchanges').value.trim());
    let maxTime = parseInt(q('#maxtime').value.trim());

    // const verbParams = (q('#verbparams').value.trim() || null);
    const topUnit = (parseInt(q('#topunit').value.trim()) || null);

    const v = [];
    const ck = document.querySelectorAll('.verblistckverb:checked');
    let i = 0;
    for (; i < ck.length; i++) {
      v.push(ck[i].value);
    }
    let unitv = v.join(',');
    if (unitv.length === 0) {
      unitv = '1,2';
    }

    reps = (reps) ? parseInt(reps) : 4;
    maxChanges = (maxChanges) ? parseInt(maxChanges) : 2;
    maxTime = (maxTime) ? parseInt(maxTime) : 30;

    const lp = [];
    const lpck = document.querySelectorAll('.limitparam:checked');
    i = 0;
    for (; i < lpck.length; i++) {
      lp.push(lpck[i].value);
    }
    let verbParams = lp.join(',');
    if (verbParams.length === 0 || lpck.length === 16) {
      verbParams = null;
    }
    // console.log('limit params: ' + verbParams);

    const sendData = {
      qtype: 'newsession',
      verbs: unitv,
      params: verbParams,
      opponent: opponentv,
      practice_reps_per_verb: reps,
      countdown,
      max_changes: maxChanges,
      max_time: maxTime
    };
    if (topUnit !== null) {
      sendData.unit = topUnit;
    }
    genericSendRequest('new', sendData, null);
  }

  function submitClicked () {
    const submitbutton = q('#submitbutton');
    if (submitbutton.innerText === 'Enter') {
      uiModeClickedEnter();

      const answer = q('#answerform').value.trim();
      const time = q('#mainTime').innerText.trim();
      console.log('Enter clicked: ' + answer + ', time: ' + time + ', mfPressed: ' + globalMFPressed + ', timedout: ' + globalTimedOut);
  
      sendAnswer(globalSessionId, answer, time, globalMFPressed, globalTimedOut);
    } else if (submitbutton.innerText === 'Continue' || submitbutton.innerText === 'Start') {
      console.log(submitbutton.innerText + ' clicked');
      uiModeAskForm2();
    } else if (submitbutton.innerText === 'Ask') {
      const vals = getParamValues();
      if (document.querySelectorAll('.paramdivchanged').length > 0 ||
                q('#verbchooser').style.display !== 'none') {
        sendAsk(globalSessionId, vals[0], vals[1], vals[2], vals[3], vals[4], vals[5]);
      } else {
        alert('you must change at least one parameter');
      }
    } else if (submitbutton.innerText === 'Go') {
      console.log(submitbutton.innerText + ' clicked');
      uiModeAnwerGoForm(globalStartingForm, globalChangeDesc);
    }
  }

  function closeClicked () {
    q('.hcform').style.display = 'none';
  }

  function mfClicked () {
    console.log('multiple forms clicked');
    if (!globalMFPressed) { // only allow clicking this once
      q('#mfbutton').disabled = true;

      addSecondsToTime(globalSeconds / 2);
      globalMFPressed = true;

      const answer = q('#answerform').value.trim();
      const time = q('#mainTime').innerText.trim();
      console.log('MF clicked: ' + answer + ', time: ' + time + ', mfPressed: ' + globalMFPressed + ', timedout: ' + globalTimedOut);

      sendMF(globalSessionId, answer, time, globalMFPressed, globalTimedOut);
    }
  }

  function mytimeout () {
    console.log('timed out');
    clearInterval(globalTimerIntV);
    globalTimedOut = true;
    globalTimerRef.innerHTML = '<span style="color:red;font-weight:bold;">00:00</span>';
    submitClicked();
  }
  
  function getMove () {
    document.querySelectorAll('.selectedGame').forEach((row) => {
      row.classList.remove('selectedGame');
    });

    collapseNewGameDiv();

    globalSessionId = this.getAttribute('data-uuid');
    if (globalSessionId) {
      this.classList.add('selectedGame');

      localStorage.setItem('selected_session_id', globalSessionId);

      const sendData = { qtype: 'getmove', session_id: globalSessionId };
      genericSendRequest('getmove', sendData, null);
    }
  }

  function getSessions (withCurrentGame) {
    // const sendData = { qtype: 'getsessions', current_session: ((withCurrentGame) ? globalSessionId : null) };
    const sendData = {};
    sendData.qtype = 'getsessions';
    if (withCurrentGame && globalSessionId !== null) {
      sendData.current_session = globalSessionId;
    }
    genericSendRequest('list', sendData, null);
  }

  function setParamsDropdowns (person, number, tense, voice, mood, verbId) {
    document.querySelectorAll('.paramdivchanged').forEach(e => e.classList.remove('paramdivchanged'));

    const p = q('#personparam');
    p.value = person;
    p.setAttribute('orig', person);
    const n = q('#numberparam');
    n.value = number;
    n.setAttribute('orig', number);
    const t = q('#tenseparam');
    t.value = tense;
    t.setAttribute('orig', tense);
    const m = q('#moodparam');
    m.value = mood;
    m.setAttribute('orig', mood);
    const v = q('#voiceparam');
    v.value = voice;
    v.setAttribute('orig', voice);
    const vc = q('#verbchooser');
    // if the dropdown doesn't have enough rows to assign value, just add a new row for it. it's ok: we can't see it
    if (verbId >= vc.options.length && vc.value !== verbId /* so we don't get two of same option */) {
      const o = document.createElement('option');
      o.value = verbId;
      o.text = '';
      vc.add(o);
    }
    vc.value = verbId;
  }

  function getParamValues () {
    const p = q('#personparam').value;
    const n = q('#numberparam').value;
    const t = q('#tenseparam').value;
    const m = q('#moodparam').value;
    const v = q('#voiceparam').value;
    const verbId = q('#verbchooser').value;

    // console.log("vals: " + p + n + t + m + v + verb_id);
    return [p, n, t, m, v, verbId];
  }

  function setGameStateClass (state) {
    document.body.classList.remove('practice', 'firstmovemyturn', 'firstmovetheirturn', 'answermyturn', 'asktheirturn', 'askmyturn', 'answertheirturn', 'gameover');
    document.body.classList.add(state);
  }

  function setUI (data) {
    q('.hcform').style.display = 'block';

    setGameStateClass(data.move_type.toLowerCase());
    switch (data.move_type) {
      case 'Practice':
        uiModePractice(data); // practice
        break;
      case 'FirstMoveMyTurn':
        uiModeAskForm(data, 5); // I need to ask first move
        break;
      case 'FirstMoveTheirTurn':
        uiModeWaitingForAsk(data); // no moves: waiting for other player to ask first move
        break;
      case 'AnswerMyTurn':
        uiModeAnwerForm(data); // I need to answer
        break;
      case 'AskTheirTurn':
        uiModeWaitingForAsk(data); // waiting for you to ask
        break;
      case 'AskMyTurn':
        uiModeAskForm(data, 2); // I need to ask
        break;
      case 'AnswerTheirTurn':
        uiModeWaitingForAnswer(data); // waiting for you to answer
        break;
      case 'GameOver':
        uiModeGameIsOver(); // game has ended
        break;
      default:
        break;
    }
  }

  const persons = ['first', 'second', 'third'];
  const numbers = ['singular', 'plural'];
  const tenses = ['present', 'imperfect', 'future', 'aorist', 'perfect', 'pluperfect'];
  const voices = ['active', 'middle', 'passive'];
  const moods = ['indicative', 'subjunctive', 'optative', 'imperative'];
  function desc (person, number, tense, mood, voice, prevp, prevn, prevt, prevm, prevv) {
    if (person !== prevp && prevp !== null) {
      person = '<b>' + persons[person] + '</b>';
    } else {
      person = persons[person];
    }
    if (number !== prevn && prevn !== null) {
      number = '<b>' + numbers[number] + '</b>';
    } else {
      number = numbers[number];
    }
    if (tense !== prevt && prevt !== null) {
      tense = '<b>' + tenses[tense] + '</b>';
    } else {
      tense = tenses[tense];
    }
    if (mood !== prevm && prevm !== null) {
      mood = '<b>' + moods[mood] + '</b>';
    } else {
      mood = moods[mood];
    }
    if (voice !== prevv && prevv !== null) {
      voice = '<b>' + voices[voice] + '</b>';
    } else {
      voice = voices[voice];
    }
    return person + ' ' + number + ' ' + tense + ' ' + mood + ' ' + voice;
  }

  function uiModeGameIsOver () {
    const submitbutton = q('#submitbutton');
    submitbutton.disabled = true;
    q('#statusmesg').innerHTML = 'Game is over.';
    q('#answerform').value = '';
    q('#answerform').disabled = true;
    q('#correctanswer').innerHTML = '';
    q('#correctanswer').style.visibility = 'hidden';
    q('#startingform').innerText = '';
    q('#mfbutton').disabled = true;
    q('#verbchooser').style.display = 'none';
  }

  // need to set prev params for first form
  function uiModePractice (data) {
    const submitbutton = q('#submitbutton');
    submitbutton.disabled = false;
    submitbutton.innerText = 'Go';
    globalStartingForm = data.starting_form;
    globalChangeDesc = desc(data.person, data.number, data.tense, data.mood, data.voice, data.person_prev, data.number_prev, data.tense_prev, data.mood_prev, data.voice_prev);
    // q("#statusmesg").innerHTML = "Click Go to answer!"
    q('#statusmesg').innerHTML = 'Practice Mode';
    q('#changedesc').innerHTML = (data.person_prev !== null) ? desc(data.person_prev, data.number_prev, data.tense_prev, data.mood_prev, data.voice_prev, null, null, null, null, null) : '';
    q('#answerform').value = '';
    q('#answerform').disabled = true;
    q('#mfbutton').disabled = true;
    q('#correctanswer').innerHTML = '';
    q('#correctanswer').style.visibility = 'hidden';
    q('#startingform').innerText = (data.starting_form) ? data.starting_form : '';

    q('#askparamsdiv').style.display = 'none';
    q('#submitbutton').style.display = 'block';
    q('#verbchooser').style.display = 'none';
  }

  function uiModeAnwerForm (data) {
    const submitbutton = q('#submitbutton');
    submitbutton.disabled = false;
    submitbutton.innerText = 'Go';
    globalStartingForm = data.starting_form;
    globalChangeDesc = desc(data.person, data.number, data.tense, data.mood, data.voice, data.person_prev, data.number_prev, data.tense_prev, data.mood_prev, data.voice_prev);
    q('#statusmesg').innerHTML = 'Click Go to answer!';
    q('#changedesc').innerHTML = (data.person_prev !== null) ? desc(data.person_prev, data.number_prev, data.tense_prev, data.mood_prev, data.voice_prev, null, null, null, null, null) : '';
    q('#answerform').value = '';
    q('#answerform').disabled = true;
    q('#mfbutton').disabled = true;
    q('#correctanswer').innerHTML = '';
    q('#correctanswer').style.visibility = 'hidden';
    q('#startingform').innerText = (data.starting_form) ? data.starting_form : '';

    q('#askparamsdiv').style.display = 'none';
    q('#submitbutton').style.display = 'block';
    q('#verbchooser').style.display = 'none';
  }

  function uiModeAnwerGoForm (locStartingForm, locChangeDesc) {
    const submitbutton = q('#submitbutton');
    submitbutton.disabled = false;
    submitbutton.innerText = 'Enter';
    globalMFPressed = false;

    q('#statusmesg').innerHTML = 'Click enter to submit!';
    q('#changedesc').innerHTML = locChangeDesc;
    q('#answerform').value = '';
    q('#answerform').disabled = false;
    q('#mfbutton').disabled = false;
    q('#answerform').focus();
    q('#correctanswer').innerHTML = '';
    q('#correctanswer').style.visibility = 'hidden';
    q('#startingform').innerText = locStartingForm;

    q('#askparamsdiv').style.display = 'none';
    startTimer();
    q('#submitbutton').style.display = 'block';
    q('#verbchooser').style.display = 'none';
  }

  function uiModeWaitingForAnswer (data) {
    const submitbutton = q('#submitbutton');
    submitbutton.disabled = true;
    q('#statusmesg').innerHTML = 'Waiting for opponent to answer.';
    q('#answerform').value = '';
    q('#answerform').disabled = true;
    q('#correctanswer').innerHTML = '';
    q('#correctanswer').style.visibility = 'hidden';
    q('#startingform').innerText = data.starting_form;

    q('#askparamsdiv').style.display = 'none';

    globalSeconds = parseInt(q('.gamerow.selectedGame').getAttribute('data-max-time'));

    q('#changedesc').innerHTML = desc(data.person, data.number, data.tense, data.mood, data.voice, data.person_prev, data.number_prev, data.tense_prev, data.mood_prev, data.voice_prev);
    q('#submitbutton').style.display = 'none';
    q('#mfbutton').disabled = true;
    q('#mainTime').innerText = globalSeconds + ':00';
    q('#verbchooser').style.display = 'none';
  }

  function uiModeWaitingForAsk (data) {
    const submitbutton = q('#submitbutton');
    submitbutton.disabled = true;
    q('#statusmesg').innerHTML = 'Waiting for opponent to ask.';
    q('#answerform').value = data.answer;
    q('#answerform').disabled = true;

    q('#correctanswer').style.visibility = 'visible';
    q('#startingform').innerText = data.starting_form;

    q('#mainTime').innerText = data.time;
    q('#askparamsdiv').style.display = 'none';
    q('#submitbutton').style.display = 'none';
    q('#mfbutton').disabled = true;

    if (data.move_type === 'FirstMoveTheirTurn') {
      q('#changedesc').innerHTML = '';
      q('#correctanswer').innerHTML = '';
    } else {
      q('#changedesc').innerHTML = desc(data.person, data.number, data.tense, data.mood, data.voice, data.person_prev, data.number_prev, data.tense_prev, data.mood_prev, data.voice_prev);
      q('#correctanswer').innerHTML = ((data.is_correct) ? correctIcon : incorrectIcon) + ' ' + ((!data.is_correct || globalShowCorrect) ? data.correct_answer : '');
    }
    q('#verbchooser').style.display = 'none';
  }

  function uiModeAskResponse (data) {
    console.log('ask successfully submitted');
    q('#mfbutton').disabled = true;
    const submitbutton = q('#submitbutton');
    submitbutton.innerText = 'Sent!';
    q('#statusmesg').innerHTML = 'Sent!';
    submitbutton.disabled = true;
    q('#askparamsdiv').style.display = 'none';
    q('#verbchooser').style.display = 'none';
    if (data.starting_form) {
      q('#startingform').innerText = data.starting_form;
    }
    q('#changedesc').innerHTML = desc(data.person, data.number, data.tense, data.mood, data.voice, data.person_prev, data.number_prev, data.tense_prev, data.mood_prev, data.voice_prev);
  }

  function uiModeAskForm (data, maxParamsToChange) {
    globalSessionState = data;
    setParamsDropdowns(data.person, data.number, data.tense, data.voice, data.mood, data.verb);

    if (data.move_type === 'FirstMoveMyTurn') {
      uiModeAskForm2();
      return;
    }

    q('#mfbutton').disabled = true;
    const submitbutton = q('#submitbutton');
    if (data.move_type === 'Practice') {
      submitbutton.innerText = 'Ask';
      q('#verbchooser').style.display = 'none';
      q('#askparamsdiv').style.display = 'block';
      q('#statusmesg').innerHTML = 'Click ask to ask this form.';
      q('#startingform').innerText = '';
      q('#changedesc').innerHTML = '';
      q('#answerform').value = '';
      q('#correctanswer').style.visibility = 'hidden';
      q('#correctanswer').innerHTML = '';
    } else {
      submitbutton.innerText = 'Continue';
      q('#verbchooser').style.display = 'none';
      q('#mainTime').innerText = data.time;
      q('#askparamsdiv').style.display = 'none';
      q('#statusmesg').innerHTML = 'Click Continue to ask the next form.';
      q('#startingform').innerText = data.starting_form;
      q('#changedesc').innerHTML = desc(data.person, data.number, data.tense, data.mood, data.voice, data.person_prev, data.number_prev, data.tense_prev, data.mood_prev, data.voice_prev);
      q('#answerform').value = data.answer;
      q('#correctanswer').style.visibility = 'visible';
      q('#correctanswer').innerHTML = ((data.is_correct) ? correctIcon : incorrectIcon) + ' ' + ((!data.is_correct || globalShowCorrect) ? data.correct_answer : '');
    }
    submitbutton.style.display = 'block';
    submitbutton.disabled = false;
  }

  function uiModeAskForm2 () {
    const data = globalSessionState;
    globalSessionState = null;

    const submitbutton = q('#submitbutton');
    submitbutton.innerText = 'Ask';
    submitbutton.style.display = 'block';
    submitbutton.disabled = false;
    q('#mfbutton').disabled = true;
    if (data.move_type === 'FirstMoveMyTurn') {
      globalMaxChanges = null; // can change all
      setParamsDropdowns(null, null, null, null, null, null);
      const verbchooser = q('#verbchooser');
      // remove verb options
      while (verbchooser.options.length > 0) {
        verbchooser.remove(0);
      }
      // add new verb options
      for (let v = 0; v < data.verbs.length; v++) {
        const o = document.createElement('option');
        o.value = data.verbs[v].id;
        o.text = data.verbs[v].verb;
        verbchooser.add(o);
      }
      verbchooser.value = null;
  
      q('#startingform').innerText = '';
      verbchooser.style.display = 'inline-block';
      q('#statusmesg').innerHTML = 'Choose a verb and set all parameters';
    } else {
      globalMaxChanges = 2;
      setParamsDropdowns(data.person, data.number, data.tense, data.voice, data.mood, data.verb);
      q('#startingform').innerText = data.correct_answer;
      q('#verbchooser').style.display = 'none';
      q('#statusmesg').innerHTML = 'Change up to (2) parameters';
    }
    globalSeconds = parseInt(q('.gamerow.selectedGame').getAttribute('data-max-time'));

    q('#mainTime').innerHTML = globalSeconds + ':00';
    q('#askparamsdiv').style.display = 'block';
    q('#changedesc').innerHTML = '';// desc(data.person, data.number, data.tense, data.mood, data.voice, data.person_prev, data.number_prev, data.tense_prev, data.mood_prev, data.voice_prev);
    // q("#changedesc").style.display = "none";
    q('#answerform').value = '';
    q('#correctanswer').style.visibility = 'hidden';
    q('#correctanswer').innerHTML = ((data.is_correct) ? correctIcon : incorrectIcon) + ' ' + ((!data.is_correct || globalShowCorrect) ? data.correct_answer : '');

    // q("#statusmesg").innerHTML = "Click Ask to ask the next form."
    // if (max_params_to_change == 5) {
    //     q("#statusmesg").innerHTML = "Choose a verb and set all params.";
    // }
    // else {
    //     q("#statusmesg").innerHTML = "Change up to (" + max_params_to_change + ") params.";
    // }
}
  function uiModeClickedEnter () {
    const submitbutton = q('#submitbutton');
    submitbutton.innerText = 'Loading...';
    submitbutton.disabled = true;
    stopTimer();
    q('#answerform').disabled = true;
  }

  function uiModeAnswerResponseReceived (data) {
    const submitbutton = q('#submitbutton');
    if (data.move_type === 'Practice') {
      submitbutton.innerText = 'Go';
      globalStartingForm = data.starting_form;
      globalChangeDesc = desc(data.person, data.number, data.tense, data.mood, data.voice, data.person_prev, data.number_prev, data.tense_prev, data.mood_prev, data.voice_prev);
      q('#statusmesg').innerHTML = 'Click Go to answer the next form.';
    } else {
      submitbutton.innerText = 'Continue';
      q('#statusmesg').innerHTML = 'Click Continue to ask the next form.';
    }
    globalSessionState = data;
    submitbutton.disabled = false;
    submitbutton.focus();
    q('#mfbutton').disabled = true;
    // mark (in)correct, show correct answer
    q('#correctanswer').style.visibility = 'visible';
    q('#correctanswer').innerHTML = ((data.is_correct) ? correctIcon : incorrectIcon) + ' ' + ((!data.is_correct || globalShowCorrect) ? data.correct_answer : '');
  }

  function addSecondsToTime (secs) {
    globalCountDownDate += (secs * 1000);
  }
  
  function startTimer () {
    const session = q('.gamerow.selectedGame');
    globalSeconds = parseInt(session.getAttribute('data-max-time'));
    globalCountDown = (session.getAttribute('data-countdown') === 'true');
    globalTimedOut = false;
    globalCountDownDate = new Date().getTime();
    if (globalCountDown) {
      globalCountDownDate += (globalSeconds * 1000);
    }
    globalTimerIntV = setInterval(intervalFunc, 10);
  }

  function stopTimer () {
    clearInterval(globalTimerIntV);
    globalTimerIntV = null;
  }

  function intervalFunc () {
    const now = new Date().getTime();
    let distance = 0;
    if (globalCountDown) {
      distance = globalCountDownDate - now;
    } else {
      distance = now - globalCountDownDate;
    }

    if (distance <= 0 && globalCountDown) {
      mytimeout();
      return;
    }

    // let days = Math.floor(distance / (1000 * 60 * 60 * 24));
    const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((distance % (1000 * 60)) / 1000);
    const ms = Math.floor((distance % (1000)) / 10);

    globalTimerRef.innerHTML = ((hours > 0) ? ((hours < 10) ? ('0' + hours + ':') : hours + ':') : '') + ((minutes > 0 || hours > 0) ? ((minutes < 10) ? ('0' + minutes + ':') : minutes + ':') : '') + ((seconds < 10) ? ('0' + seconds + ':') : seconds + ':') + ((ms < 10) ? ('0' + ms) : ms);
  }

  //   const $status = q('#status')
  //   const $connectButton = q('#connect')
  //   const $log = q('#log')
  //   const $form = q('#chatform')
  //   const $input = q('#text')

  /** @type {WebSocket | null} */
  let socket = null;

  //   function log(msg, type = 'status') {
  //     $log.innerHTML += `<p class="msg msg--${type}">${msg}</p>`
  //     $log.scrollTop += 1000
  //   }

  // const visibilityCheck = false;
  function wsconnect () {
    // wsdisconnect()

    const { location } = window;

    const proto = location.protocol.startsWith('https') ? 'wss' : 'ws';
    const wsUri = `${proto}://${location.host}/ws`;

    // log('Connecting...')
    // socket = new WebSocket(wsUri);
    socket = null;
    // eslint-disable-next-line no-undef
    socket = new ReconnectingWebSocket(wsUri, null, { debug: true });

    socket.onopen = () => {
      console.log('ws connected');
      // log('Connected')
      updateConnectionStatus();
      /*
          if (pendingSendData) {
              genericSendRequest(null, pendingSendData, null);
              pendingSendData = null;
          }
          if (!visibilityCheck) {
              //https://stackoverflow.com/questions/1060008/is-there-a-way-to-detect-if-a-browser-window-is-not-currently-active
              document.addEventListener("visibilitychange", onchange);
              function onchange (evt) {
                  if (document.hidden) {
                      console.log("document hidden");
                  }
                  else {
                      console.log("document visible");
                      if (!socket) {
                          wsconnect();
                      }
                  }
              }
              visibilityCheck = true;
          } */
    };

    socket.onmessage = (ev) => {
      console.log('websocket data received');// + ev.data);
      try {
        const json = JSON.parse(ev.data);
        procResponse(json);
      } catch (e) { console.log(e.message); }
    };

    socket.onclose = () => {
      console.log('ws disconnected');
      // socket = null
      // updateConnectionStatus()
    };
  }

  //   function try_ws_reconnect() {
  //     if (!socket) {
  //         wsconnect();
  //         //setTimeout(try_ws_reconnect, 4000);
  //     }
  //   }

  //   function wsdisconnect() {
  //     if (socket) {
  //       //log('Disconnecting...')
  //       socket.close()
  //       socket = null

  //       updateConnectionStatus()
  //     }
  //   }

  function updateConnectionStatus () {
    if (socket) {
      //   $status.style.backgroundColor = 'transparent'
      //   $status.style.color = 'green'
      //   $status.textContent = `connected`
      //   $connectButton.innerHTML = 'Disconnect'
      // $input.focus()
      getSessions(true);
    } else {
      //   $status.style.backgroundColor = 'red'
      //   $status.style.color = 'white'
      //   $status.textContent = 'disconnected'
      //   $connectButton.textContent = 'Connect'
    }
  }

  // document.addEventListener("visibilitychange", () => {
  //     console.log(document.hidden);
  //     try_ws_reconnect();
  //     // Modify behavior…
  // });

  //   $connectButton.addEventListener('click', () => {
  //     if (socket) {
  //       wsdisconnect()
  //     } else {
  //         wsconnect()
  //     }

  //     updateConnectionStatus()
  //   })

  //   $form.addEventListener('submit', (ev) => {
  //     ev.preventDefault()

  //     const text = $input.value

  //     //log('Sending: ' + text)
  //     socket.send(text)

  //     $input.value = ''
  //     $input.focus()
  //   })

  updateConnectionStatus();

  function verbList () {
    const list = q('#verblist');
    let rows = "<div class='verbunitrow'><span class='verbunitrowlabel'>H&Q verbs</span></div><div class='expand-container'><div id='verbscontainer' class='expand-contract'>";
    rows += "<div class='verbunitrow'><input class='verblistck verblistckunit' id='ckuall' type='checkbox'/>all</div>";
    let i = 0;
    let lastUnit = null;
    for (; i < verbs.length; i++) {
      if (verbs[i].i === 122 || verbs[i].i === 127 || verbs[i].i === 78 || verbs[i].i === 79) {
        continue;
      }
      let end = ',';
      let plus = 0;
      if (verbs[i].pp[0] === '—') { // -, erhsomai and -, anerhsomai
        end = 'ι,';
        plus = 1;
      }
      if (verbs[i].u !== lastUnit) {
        if (lastUnit !== null) {
          rows += '</div></div>';
        }
        lastUnit = verbs[i].u;

        rows += "<div class='verbunitrow'><input class='verblistck verblistckunit' id='cku" + verbs[i].u + "' value='" + verbs[i].u + "' type='checkbox'/><span class='verbunitrowlabel'>unit " + verbs[i].u + '</span></div>';
        rows += "<div class='expand-container'><div id='unitdiv" + verbs[i].u + "' class='expand-contract'>";
      }
      rows += "<div class='verbrow'><input class='verblistck verblistckverb' id='ckv" + verbs[i].i + "' value='" + verbs[i].i + "' type='checkbox'/>" + verbs[i].pp.substring(0, (verbs[i].pp.indexOf(end) + plus)) + '</div>';
    }
    rows += '</div></div></div></div>';
    list.innerHTML = rows;

    const rowItems = document.querySelectorAll('.verbunitrowlabel');
    for (let i = 0; i < rowItems.length; i++) {
      rowItems[i].addEventListener('click', expandContractGames, false);
    }

    const all = document.querySelector('#ckuall');
    // unit notes
    const c = document.querySelectorAll('.verblistckunit');
    let j = 0;
    for (j = 0; j < c.length; j++) {
      c[j].addEventListener('click', function () {
        let checked = true;
        if (!this.checked) {
          checked = false;
          all.checked = false;
        }
        const a = this.parentNode.nextSibling.querySelectorAll('.verblistck');
        let k = 0;
        for (k = 0; k < a.length; k++) {
          a[k].checked = checked;
        }
      });
    }
    // verb leaves
    const vv = document.querySelectorAll('.verblistckverb');
    let k = 0;
    for (; k < vv.length; k++) {
      vv[k].addEventListener('click', function () {
        if (!this.checked) {
          all.checked = false;
          this.parentNode.parentNode.parentNode.previousSibling.firstChild.checked = false;
        }
      });
    }
    // all
    all.addEventListener('click', function () {
      let checked = false;
      if (this.checked) {
        checked = true;
      }
      const a = document.querySelectorAll('.verblistck');
      let k = 0;
      for (k = 0; k < a.length; k++) {
        a[k].checked = checked;
      }
    });
  }

  function expandContractNewGameDiv () {
    globalSessionId = null;
    document.querySelector('.hcform').style.display = 'none';
    const el = document.getElementById('newgamediv');
    if (el) {
      el.classList.toggle('expanded');
      // collapse all expanded divs below this one
      el.querySelectorAll('.expand-contract').forEach(e => e.classList.remove('expanded'));
    }
  }

  function collapseNewGameDiv () {
    const el = document.getElementById('newgamediv');
    if (el) {
      el.classList.remove('expanded');
      // collapse all expanded divs below this one
      el.querySelectorAll('.expand-contract').forEach(e => e.classList.remove('expanded'));
    }
  }

  function expandContractGames () {
    const el = this.parentNode.nextSibling.firstChild;
    if (el) {
      el.classList.toggle('expanded');
      // collapse all expanded divs below this one
      el.querySelectorAll('.expand-contract').forEach(e => e.classList.remove('expanded'));
    }
  }

  const verbs = [
    { i: 1, pp: 'παιδεύω, παιδεύσω, ἐπαίδευσα, πεπαίδευκα, πεπαίδευμαι, ἐπαιδεύθην', u: 2 },
    { i: 2, pp: 'πέμπω, πέμψω, ἔπεμψα, πέπομφα, πέπεμμαι, ἐπέμφθην', u: 2 },
    { i: 3, pp: 'κελεύω, κελεύσω, ἐκέλευσα, κεκέλευκα, κεκέλευσμαι, ἐκελεύσθην', u: 2 },
    { i: 4, pp: 'λῡ́ω, λῡ́σω, ἔλῡσα, λέλυκα, λέλυμαι, ἐλύθην', u: 2 },
    { i: 5, pp: 'γράφω, γράψω, ἔγραψα, γέγραφα, γέγραμμαι, ἐγράφην', u: 3 },
    { i: 6, pp: 'θῡ́ω, θῡ́σω, ἔθῡσα, τέθυκα, τέθυμαι, ἐτύθην', u: 3 },
    { i: 7, pp: 'παύω, παύσω, ἔπαυσα, πέπαυκα, πέπαυμαι, ἐπαύθην', u: 3 },
    { i: 8, pp: 'φυλάττω, φυλάξω, ἐφύλαξα, πεφύλαχα, πεφύλαγμαι, ἐφυλάχθην', u: 3 },
    { i: 9, pp: 'διδάσκω, διδάξω, ἐδίδαξα, δεδίδαχα, δεδίδαγμαι, ἐδιδάχθην', u: 4 },
    { i: 10, pp: 'ἐθέλω, ἐθελήσω, ἠθέλησα, ἠθέληκα, —, —', u: 4 },
    { i: 11, pp: 'θάπτω, θάψω, ἔθαψα, —, τέθαμμαι, ἐτάφην', u: 4 },
    { i: 12, pp: 'τάττω, τάξω, ἔταξα, τέταχα, τέταγμαι, ἐτάχθην', u: 4 },
    { i: 13, pp: 'ἄρχω, ἄρξω, ἦρξα, ἦρχα, ἦργμαι, ἤρχθην', u: 5 },
    { i: 14, pp: 'βλάπτω, βλάψω, ἔβλαψα, βέβλαφα, βέβλαμμαι, ἐβλάβην / ἐβλάφθην', u: 5 },
    { i: 15, pp: 'πείθω, πείσω, ἔπεισα, πέπεικα, πέπεισμαι, ἐπείσθην', u: 5 },
    { i: 16, pp: 'πρᾱ́ττω, πρᾱ́ξω, ἔπρᾱξα, πέπρᾱχα / πέπρᾱγα, πέπρᾱγμαι, ἐπρᾱ́χθην', u: 5 },
    { i: 17, pp: 'δουλεύω, δουλεύσω, ἐδούλευσα, δεδούλευκα, —, —', u: 6 },
    { i: 18, pp: 'κωλῡ́ω, κωλῡ́σω, ἐκώλῡσα, κεκώλῡκα, κεκώλῡμαι, ἐκωλῡ́θην', u: 6 },
    { i: 19, pp: 'πολῑτεύω, πολῑτεύσω, ἐπολῑ́τευσα, πεπολῑ́τευκα, πεπολῑ́τευμαι, ἐπολῑτεύθην', u: 6 },
    { i: 20, pp: 'χορεύω, χορεύσω, ἐχόρευσα, κεχόρευκα, κεχόρευμαι, ἐχορεύθην', u: 6 },
    { i: 21, pp: 'κλέπτω, κλέψω, ἔκλεψα, κέκλοφα, κέκλεμμαι, ἐκλάπην', u: 7 },
    { i: 22, pp: 'λείπω, λείψω, ἔλιπον, λέλοιπα, λέλειμμαι, ἐλείφθην', u: 7 },
    { i: 23, pp: 'σῴζω, σώσω, ἔσωσα, σέσωκα, σέσωσμαι / σέσωμαι, ἐσώθην', u: 7 },
    { i: 24, pp: 'ἄγω, ἄξω, ἤγαγον, ἦχα, ἦγμαι, ἤχθην', u: 8 },
    { i: 25, pp: 'ἥκω, ἥξω, —, —, —, —', u: 8 },
    { i: 26, pp: 'ἀδικέω, ἀδικήσω, ἠδίκησα, ἠδίκηκα, ἠδίκημαι, ἠδικήθην', u: 9 },
    { i: 27, pp: 'νῑκάω, νῑκήσω, ἐνῑ́κησα, νενῑ́κηκα, νενῑ́κημαι, ἐνῑκήθην', u: 9 },
    { i: 28, pp: 'ποιέω, ποιήσω, ἐποίησα, πεποίηκα, πεποίημαι, ἐποιήθην', u: 9 },
    { i: 29, pp: 'τῑμάω, τῑμήσω, ἐτῑ́μησα, τετῑ́μηκα, τετῑ́μημαι, ἐτῑμήθην', u: 9 },
    { i: 30, pp: 'ἀγγέλλω, ἀγγελῶ, ἤγγειλα, ἤγγελκα, ἤγγελμαι, ἠγγέλθην', u: 10 },
    { i: 31, pp: 'ἀξιόω, ἀξιώσω, ἠξίωσα, ἠξίωκα, ἠξίωμαι, ἠξιώθην', u: 10 },
    { i: 32, pp: 'δηλόω, δηλώσω, ἐδήλωσα, δεδήλωκα, δεδήλωμαι, ἐδηλώθην', u: 10 },
    { i: 33, pp: 'καλέω, καλῶ, ἐκάλεσα, κέκληκα, κέκλημαι, ἐκλήθην', u: 10 },
    { i: 34, pp: 'μένω, μενῶ, ἔμεινα, μεμένηκα, —, —', u: 10 },
    { i: 35, pp: 'τελευτάω, τελευτήσω, ἐτελεύτησα, τετελεύτηκα, τετελεύτημαι, ἐτελευτήθην', u: 10 },
    { i: 36, pp: 'ἀκούω, ἀκούσομαι, ἤκουσα, ἀκήκοα, —, ἠκούσθην', u: 11 },
    { i: 37, pp: 'ἀποδέχομαι, ἀποδέξομαι, ἀπεδεξάμην, —, ἀποδέδεγμαι, —', u: 11 },
    { i: 38, pp: 'βάλλω, βαλῶ, ἔβαλον, βέβληκα, βέβλημαι, ἐβλήθην', u: 11 },
    { i: 39, pp: 'βούλομαι, βουλήσομαι, —, —, βεβούλημαι, ἐβουλήθην', u: 11 },
    { i: 40, pp: 'δέχομαι, δέξομαι, ἐδεξάμην, —, δέδεγμαι, —', u: 11 },
    { i: 41, pp: 'λαμβάνω, λήψομαι, ἔλαβον, εἴληφα, εἴλημμαι, ἐλήφθην', u: 11 },
    { i: 42, pp: 'πάσχω, πείσομαι, ἔπαθον, πέπονθα, —, —', u: 11 },
    { i: 43, pp: 'ἀνατίθημι, ἀναθήσω, ἀνέθηκα, ἀνατέθηκα, ἀνατέθειμαι, ἀνετέθην', u: 12 },
    { i: 44, pp: 'ἀποδίδωμι, ἀποδώσω, ἀπέδωκα, ἀποδέδωκα, ἀποδέδομαι, ἀπεδόθην', u: 12 },
    { i: 45, pp: 'ἀφίστημι, ἀποστήσω, ἀπέστησα / ἀπέστην, ἀφέστηκα, ἀφέσταμαι, ἀπεστάθην', u: 12 },
    { i: 46, pp: 'δίδωμι, δώσω, ἔδωκα, δέδωκα, δέδομαι, ἐδόθην', u: 12 },
    { i: 47, pp: 'ἵστημι, στήσω, ἔστησα / ἔστην, ἕστηκα, ἕσταμαι, ἐστάθην', u: 12 },
    { i: 48, pp: 'καθίστημι, καταστήσω, κατέστησα / κατέστην, καθέστηκα, καθέσταμαι, κατεστάθην', u: 12 },
    { i: 49, pp: 'καταλῡ́ω, καταλῡ́σω, κατέλῡσα, καταλέλυκα, καταλέλυμαι, κατελύθην', u: 12 },
    { i: 50, pp: 'τίθημι, θήσω, ἔθηκα, τέθηκα, τέθειμαι, ἐτέθην', u: 12 },
    { i: 51, pp: 'φιλέω, φιλήσω, ἐφίλησα, πεφίληκα, πεφίλημαι, ἐφιλήθην', u: 12 },
    { i: 52, pp: 'φοβέομαι, φοβήσομαι, —, —, πεφόβημαι, ἐφοβήθην', u: 12 },
    { i: 53, pp: 'γίγνομαι, γενήσομαι, ἐγενόμην, γέγονα, γεγένημαι, —', u: 13 },
    { i: 54, pp: 'ἔρχομαι, ἐλεύσομαι, ἦλθον, ἐλήλυθα, —, —', u: 13 },
    { i: 55, pp: 'μανθάνω, μαθήσομαι, ἔμαθον, μεμάθηκα, —, —', u: 13 },
    { i: 56, pp: 'μάχομαι, μαχοῦμαι, ἐμαχεσάμην, —, μεμάχημαι, —', u: 13 },
    { i: 57, pp: 'μεταδίδωμι, μεταδώσω, μετέδωκα, μεταδέδωκα, μεταδέδομαι, μετεδόθην', u: 13 },
    { i: 58, pp: 'μετανίσταμαι, μεταναστήσομαι, μετανέστην, μετανέστηκα, —, —', u: 13 },
    { i: 59, pp: 'μηχανάομαι, μηχανήσομαι, ἐμηχανησάμην, —, μεμηχάνημαι, —', u: 13 },
    { i: 60, pp: 'φεύγω, φεύξομαι, ἔφυγον, πέφευγα, —, —', u: 13 },
    { i: 61, pp: 'δείκνῡμι, δείξω, ἔδειξα, δέδειχα, δέδειγμαι, ἐδείχθην', u: 14 },
    { i: 62, pp: 'ἐπανίσταμαι, ἐπαναστήσομαι, ἐπανέστην, ἐπανέστηκα, —, —', u: 14 },
    { i: 63, pp: 'ἐπιδείκνυμαι, ἐπιδείξομαι, ἐπεδειξάμην, —, ἐπιδέδειγμαι, —', u: 14 },
    { i: 64, pp: 'ἐρωτάω, ἐρωτήσω, ἠρώτησα, ἠρώτηκα, ἠρώτημαι, ἠρωτήθην', u: 14 },
    { i: 65, pp: 'λανθάνω, λήσω, ἔλαθον, λέληθα, —, —', u: 14 },
    { i: 66, pp: 'παραγίγνομαι, παραγενήσομαι, παρεγενόμην, παραγέγονα, παραγεγένημαι, —', u: 14 },
    { i: 67, pp: 'παραδίδωμι, παραδώσω, παρέδωκα, παραδέδωκα, παραδέδομαι, παρεδόθην', u: 14 },
    { i: 68, pp: 'παραμένω, παραμενῶ, παρέμεινα, παραμεμένηκα, —, —', u: 14 },
    { i: 69, pp: 'τυγχάνω, τεύξομαι, ἔτυχον, τετύχηκα, —, —', u: 14 },
    { i: 70, pp: 'ὑπακούω, ὑπακούσομαι, ὑπηκουσα, ὑπακήκοα, —, ὑπηκούσθην', u: 14 },
    { i: 71, pp: 'ὑπομένω, ὑπομενῶ, ὑπέμεινα, ὑπομεμένηκα, —, —', u: 14 },
    { i: 72, pp: 'φθάνω, φθήσομαι, ἔφθασα / ἔφθην, —, —, —', u: 14 },
    { i: 73, pp: 'χαίρω, χαιρήσω, —, κεχάρηκα, —, ἐχάρην', u: 14 },
    { i: 74, pp: 'αἱρέω, αἱρήσω, εἷλον, ᾕρηκα, ᾕρημαι, ᾑρέθην', u: 15 },
    { i: 75, pp: 'αἰσθάνομαι, αἰσθήσομαι, ᾐσθόμην, —, ᾔσθημαι, —', u: 15 },
    { i: 76, pp: 'διαφέρω, διοίσω, διήνεγκα / διήνεγκον, διενήνοχα, διενήνεγμαι, διηνέχθην', u: 15 },
    { i: 77, pp: 'εἰμί, ἔσομαι, —, —, —, —', u: 15 },
    { i: 78, pp: 'ἔστι(ν), ἔσται, —, —, —, —', u: 15 },
    { i: 79, pp: 'ἔξεστι(ν), ἐξέσται, —, —, —, —', u: 15 },
    { i: 80, pp: 'ἕπομαι, ἕψομαι, ἑσπόμην, —, —, —', u: 15 },
    { i: 81, pp: 'ὁράω, ὄψομαι, εἶδον, ἑόρᾱκα / ἑώρᾱκα, ἑώρᾱμαι / ὦμμαι, ὤφθην', u: 15 },
    { i: 82, pp: 'συμφέρω, συνοίσω, συνήνεγκα / συνήνεγκον, συνενήνοχα, συνενήνεγμαι, συνηνέχθην', u: 15 },
    { i: 83, pp: 'φέρω, οἴσω, ἤνεγκα / ἤνεγκον, ἐνήνοχα, ἐνήνεγμαι, ἠνέχθην', u: 15 },
    { i: 84, pp: 'ἀναβαίνω, ἀναβήσομαι, ἀνέβην, ἀναβέβηκα, —, —', u: 16 },
    { i: 85, pp: 'βαίνω, -βήσομαι, -ἔβην, βέβηκα, —, —', u: 16 },
    { i: 86, pp: 'γιγνώσκω, γνώσομαι, ἔγνων, ἔγνωκα, ἔγνωσμαι, ἐγνώσθην', u: 16 },
    { i: 87, pp: 'ἐκπῑ́πτω, ἐκπεσοῦμαι, ἐξέπεσον, ἐκπέπτωκα, —, —', u: 16 },
    { i: 88, pp: 'λέγω, ἐρῶ / λέξω, εἶπον / ἔλεξα, εἴρηκα, εἴρημαι / λέλεγμαι, ἐλέχθην / ἐρρήθην', u: 16 },
    { i: 89, pp: 'νομίζω, νομιῶ, ἐνόμισα, νενόμικα, νενόμισμαι, ἐνομίσθην', u: 16 },
    { i: 90, pp: 'πῑ́πτω, πεσοῦμαι, ἔπεσον, πέπτωκα, —, —', u: 16 },
    { i: 91, pp: 'προδίδωμι, προδώσω, προέδωκα / προύδωκα, προδέδωκα, προδέδομαι, προεδόθην / προυδόθην', u: 16 },
    { i: 92, pp: 'φημί, φήσω, ἔφησα, —, —, —', u: 16 },
    { i: 93, pp: 'ἁμαρτάνω, ἁμαρτήσομαι, ἥμαρτον, ἡμάρτηκα, ἡμάρτημαι, ἡμαρτήθην', u: 17 },
    { i: 94, pp: 'δοκέω, δόξω, ἔδοξα, —, δέδογμαι, -ἐδόχθην', u: 17 },
    { i: 95, pp: 'δύναμαι, δυνήσομαι, —, —, δεδύνημαι, ἐδυνήθην', u: 17 },
    { i: 96, pp: 'εἶμι, —, —, —, —, —', u: 17 },
    { i: 97, pp: 'ἐλαύνω, ἐλῶ, ἤλασα, -ἐλήλακα, ἐλήλαμαι, ἠλάθην', u: 17 },
    { i: 98, pp: 'ἐπίσταμαι, ἐπιστήσομαι, —, —, —, ἠπιστήθην', u: 17 },
    { i: 99, pp: 'ἔχω, ἕξω / σχήσω, ἔσχον, ἔσχηκα, -ἔσχημαι, —', u: 17 },
    { i: 100, pp: 'ἀποθνῄσκω, ἀποθανοῦμαι, ἀπέθανον, τέθνηκα, —, —', u: 18 },
    { i: 101, pp: 'ἀποκτείνω, ἀποκτενῶ, ἀπέκτεινα, ἀπέκτονα, —, —', u: 18 },
    { i: 102, pp: 'ἀφῑ́ημι, ἀφήσω, ἀφῆκα, ἀφεῖκα, ἀφεῖμαι, ἀφείθην', u: 18 },
    { i: 103, pp: 'βουλεύω, βουλεύσω, ἐβούλευσα, βεβούλευκα, βεβούλευμαι, ἐβουλεύθην', u: 18 },
    { i: 104, pp: 'ἐπιβουλεύω, ἐπιβουλεύσω, ἐπεβούλευσα, ἐπιβεβούλευκα, ἐπιβεβούλευμαι, ἐπεβουλεύθην', u: 18 },
    { i: 105, pp: 'ζητέω, ζητήσω, ἐζήτησα, ἐζήτηκα, —, ἐζητήθην', u: 18 },
    { i: 106, pp: 'ῑ̔́ημι, -ἥσω, -ἧκα, -εἷκα, -εἷμαι, -εἵθην', u: 18 },
    { i: 107, pp: 'μέλλω, μελλήσω, ἐμέλλησα, —, —, —', u: 18 },
    { i: 108, pp: 'πιστεύω, πιστεύσω, ἐπίστευσα, πεπίστευκα, πεπίστευμαι, ἐπιστεύθην', u: 18 },
    { i: 109, pp: 'συμβουλεύω, συμβουλεύσω, συνεβούλευσα, συμβεβούλευκα, συμβεβούλευμαι, συνεβουλεύθην', u: 18 },
    { i: 110, pp: 'συνῑ́ημι, συνήσω, συνῆκα, συνεῖκα, συνεῖμαι, συνείθην', u: 18 },
    { i: 111, pp: 'αἰσχῡ́νομαι, αἰσχυνοῦμαι, —, —, ᾔσχυμμαι, ᾐσχύνθην', u: 19 },
    { i: 112, pp: 'ἀποκρῑ́νομαι, ἀποκρινοῦμαι, ἀπεκρῑνάμην, —, ἀποκέκριμαι, —', u: 19 },
    { i: 113, pp: 'ἀπόλλῡμι, ἀπολῶ, ἀπώλεσα / ἀπωλόμην, ἀπολώλεκα / ἀπόλωλα, —, —', u: 19 },
    { i: 114, pp: '—, ἀνερήσομαι, ἀνηρόμην, —, —, —', u: 19 },
    { i: 115, pp: '—, ἐρήσομαι, ἠρόμην, —, —, —', u: 19 },
    { i: 116, pp: 'εὑρίσκω, εὑρήσω, ηὗρον, ηὕρηκα, ηὕρημαι, ηὑρέθην', u: 19 },
    { i: 117, pp: 'ἡγέομαι, ἡγήσομαι, ἡγησάμην, —, ἥγημαι, ἡγήθην', u: 19 },
    { i: 118, pp: 'κρῑ́νω, κρινῶ, ἔκρῑνα, κέκρικα, κέκριμαι, ἐκρίθην', u: 19 },
    { i: 119, pp: 'οἶδα, εἴσομαι, —, —, —, —', u: 19 },
    { i: 120, pp: 'σύνοιδα, συνείσομαι, —, —, —, —', u: 19 },
    { i: 121, pp: 'ἀφικνέομαι, ἀφίξομαι, ἀφῑκόμην, —, ἀφῖγμαι, —', u: 20 },
    { i: 122, pp: 'δεῖ, δεήσει, ἐδέησε(ν), —, —, —', u: 20 },
    { i: 123, pp: 'κεῖμαι, κείσομαι, —, —, —, —', u: 20 },
    { i: 124, pp: 'πυνθάνομαι, πεύσομαι, ἐπυθόμην, —, πέπυσμαι, —', u: 20 },
    { i: 125, pp: 'τρέπω, τρέψω, ἔτρεψα / ἐτραπόμην, τέτροφα, τέτραμμαι, ἐτράπην / ἐτρέφθην', u: 20 },
    { i: 126, pp: 'φαίνω, φανῶ, ἔφηνα, πέφηνα, πέφασμαι, ἐφάνην', u: 20 },
    { i: 127, pp: 'χρή, χρῆσται, —, —, —, —', u: 20 }
  ];
  </script>
</body>
</html>
